From c617af0e078307484930384232ec1cd8d33eed2c Mon Sep 17 00:00:00 2001
From: Romuald JEANNE <romuald.jeanne@st.com>
Date: Tue, 13 Nov 2018 12:26:32 +0100
Subject: [PATCH 12/52] ARM: stm32mp1-r0-rc1: PINCTRL PWM RESET RTC

---
 drivers/pinctrl/Kconfig                     |   12 +
 drivers/pinctrl/Makefile                    |    1 +
 drivers/pinctrl/pinctrl-stmfx.c             |  821 ++++++++++++++++++++
 drivers/pinctrl/stm32/pinctrl-stm32.c       |  203 ++++-
 drivers/pinctrl/stm32/pinctrl-stm32.h       |   52 +-
 drivers/pinctrl/stm32/pinctrl-stm32mp157.c  | 1095 ++++++++++++++++-----------
 drivers/pwm/pwm-stm32-lp.c                  |   44 ++
 drivers/pwm/pwm-stm32.c                     |  103 ++-
 drivers/pwm/sysfs.c                         |   12 +-
 drivers/regulator/Kconfig                   |   19 +
 drivers/regulator/Makefile                  |    2 +
 drivers/regulator/stm32-pwr.c               |  242 ++++++
 drivers/regulator/stm32-vrefbuf.c           |  123 ++-
 drivers/regulator/stpmic1_regulator.c       |  674 +++++++++++++++++
 drivers/reset/reset-stm32mp1.c              |   48 ++
 drivers/rtc/Kconfig                         |    1 +
 drivers/rtc/rtc-stm32.c                     |  119 +++
 include/dt-bindings/pinctrl/stm32-pinfunc.h |    6 +
 include/dt-bindings/rtc/rtc-stm32.h         |   13 +
 19 files changed, 3084 insertions(+), 506 deletions(-)
 create mode 100644 drivers/pinctrl/pinctrl-stmfx.c
 create mode 100644 drivers/regulator/stm32-pwr.c
 create mode 100644 drivers/regulator/stpmic1_regulator.c
 create mode 100644 include/dt-bindings/rtc/rtc-stm32.h

diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index e86752b..bbd3908 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -244,6 +244,18 @@ config PINCTRL_ST
 	select PINCONF
 	select GPIOLIB_IRQCHIP
 
+config PINCTRL_STMFX
+	tristate "STMicroelectronics STMFX GPIO expander pinctrl driver"
+	select GENERIC_PINCONF
+	select GPIOLIB_IRQCHIP
+	select MFD_STMFX
+	help
+	  Driver for STMicroelectronics Multi-Function eXpander (STMFX)
+	  GPIO expander.
+	  This provides a GPIO interface supporting inputs and outputs,
+	  and configuring push-pull, open-drain, and can also be used as
+	  interrupt-controller.
+
 config PINCTRL_U300
 	bool "U300 pin controller driver"
 	depends on ARCH_U300
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 46ef9bd..9abcaa59 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_PINCTRL_LANTIQ)	+= pinctrl-lantiq.o
 obj-$(CONFIG_PINCTRL_LPC18XX)	+= pinctrl-lpc18xx.o
 obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
+obj-$(CONFIG_PINCTRL_STMFX) 	+= pinctrl-stmfx.o
 obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
 obj-$(CONFIG_PINCTRL_INGENIC)	+= pinctrl-ingenic.o
 obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
new file mode 100644
index 0000000..e253ed1
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -0,0 +1,821 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STMicroelectronics Multi-Function eXpander (STMFX) GPIO expander
+ *
+ * Copyright (C) 2018 STMicroelectronics
+ * Author(s): Amelie Delaunay <amelie.delaunay@st.com>.
+ */
+#include <linux/gpio/driver.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/stmfx.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinmux.h>
+
+#include "core.h"
+#include "pinctrl-utils.h"
+
+/* GPIOs expander */
+/* GPIO_STATE1 0x10, GPIO_STATE2 0x11, GPIO_STATE3 0x12 */
+#define STMFX_REG_GPIO_STATE		0x10 /* R */
+/* GPIO_DIR1 0x60, GPIO_DIR2 0x61, GPIO_DIR3 0x63 */
+#define STMFX_REG_GPIO_DIR		0x60 /* RW */
+/* GPIO_TYPE1 0x64, GPIO_TYPE2 0x65, GPIO_TYPE3 0x66 */
+#define STMFX_REG_GPIO_TYPE		0x64 /* RW */
+/* GPIO_PUPD1 0x68, GPIO_PUPD2 0x69, GPIO_PUPD3 0x6A */
+#define STMFX_REG_GPIO_PUPD		0x68 /* RW */
+/* GPO_SET1 0x6C, GPO_SET2 0x6D, GPO_SET3 0x6E */
+#define STMFX_REG_GPO_SET		0x6C /* RW */
+/* GPO_CLR1 0x70, GPO_CLR2 0x71, GPO_CLR3 0x72 */
+#define STMFX_REG_GPO_CLR		0x70 /* RW */
+/* IRQ_GPI_SRC1 0x48, IRQ_GPI_SRC2 0x49, IRQ_GPI_SRC3 0x4A */
+#define STMFX_REG_IRQ_GPI_SRC		0x48 /* RW */
+/* IRQ_GPI_EVT1 0x4C, IRQ_GPI_EVT2 0x4D, IRQ_GPI_EVT3 0x4E */
+#define STMFX_REG_IRQ_GPI_EVT		0x4C /* RW */
+/* IRQ_GPI_TYPE1 0x50, IRQ_GPI_TYPE2 0x51, IRQ_GPI_TYPE3 0x52 */
+#define STMFX_REG_IRQ_GPI_TYPE		0x50 /* RW */
+/* IRQ_GPI_PENDING1 0x0C, IRQ_GPI_PENDING2 0x0D, IRQ_GPI_PENDING3 0x0E*/
+#define STMFX_REG_IRQ_GPI_PENDING	0x0C /* R */
+/* IRQ_GPI_ACK1 0x54, IRQ_GPI_ACK2 0x55, IRQ_GPI_ACK3 0x56 */
+#define STMFX_REG_IRQ_GPI_ACK		0x54 /* RW */
+
+/* STMFX_REG_IRQ_PENDING bitfields */
+#define STMFX_REG_IRQ_PENDING_GPIO	BIT(0)
+
+#define NR_GPIO_REGS			3
+#define NR_GPIOS_PER_REG		8
+#define get_reg(offset)			((offset) / NR_GPIOS_PER_REG)
+#define get_shift(offset)		((offset) % NR_GPIOS_PER_REG)
+#define get_mask(offset)		(BIT(get_shift(offset)))
+
+/*
+ * STMFX pinctrl can have up to 24 pins if STMFX other functions are not used.
+ * Pins availability is managed thanks to gpio-ranges property.
+ */
+static const struct pinctrl_pin_desc stmfx_pins[] = {
+	PINCTRL_PIN(0, "gpio0"),
+	PINCTRL_PIN(1, "gpio1"),
+	PINCTRL_PIN(2, "gpio2"),
+	PINCTRL_PIN(3, "gpio3"),
+	PINCTRL_PIN(4, "gpio4"),
+	PINCTRL_PIN(5, "gpio5"),
+	PINCTRL_PIN(6, "gpio6"),
+	PINCTRL_PIN(7, "gpio7"),
+	PINCTRL_PIN(8, "gpio8"),
+	PINCTRL_PIN(9, "gpio9"),
+	PINCTRL_PIN(10, "gpio10"),
+	PINCTRL_PIN(11, "gpio11"),
+	PINCTRL_PIN(12, "gpio12"),
+	PINCTRL_PIN(13, "gpio13"),
+	PINCTRL_PIN(14, "gpio14"),
+	PINCTRL_PIN(15, "gpio15"),
+	PINCTRL_PIN(16, "agpio0"),
+	PINCTRL_PIN(17, "agpio1"),
+	PINCTRL_PIN(18, "agpio2"),
+	PINCTRL_PIN(19, "agpio3"),
+	PINCTRL_PIN(20, "agpio4"),
+	PINCTRL_PIN(21, "agpio5"),
+	PINCTRL_PIN(22, "agpio6"),
+	PINCTRL_PIN(23, "agpio7"),
+};
+
+struct stmfx_pinctrl {
+	struct device *dev;
+	struct stmfx *stmfx;
+	struct pinctrl_dev *pctl_dev;
+	struct pinctrl_desc pctl_desc;
+	struct gpio_chip gpio_chip;
+	struct irq_chip irq_chip;
+	struct mutex lock; /* IRQ bus lock */
+	unsigned long gpio_valid_mask;
+	/* Cache of IRQ_GPI_* registers for bus_lock */
+	u8 irq_gpi_src[NR_GPIO_REGS];
+	u8 irq_gpi_type[NR_GPIO_REGS];
+	u8 irq_gpi_evt[NR_GPIO_REGS];
+	u8 irq_toggle_edge[NR_GPIO_REGS];
+#ifdef CONFIG_PM
+	/* Backup of GPIO_* registers for suspend/resume */
+	u8 bkp_gpio_state[NR_GPIO_REGS];
+	u8 bkp_gpio_dir[NR_GPIO_REGS];
+	u8 bkp_gpio_type[NR_GPIO_REGS];
+	u8 bkp_gpio_pupd[NR_GPIO_REGS];
+#endif
+};
+
+static int stmfx_gpio_get(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_STATE + get_reg(offset);
+	u32 mask = get_mask(offset);
+	u32 value;
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &value);
+
+	return ret ? ret : !!(value & mask);
+}
+
+static void stmfx_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = value ? STMFX_REG_GPO_SET : STMFX_REG_GPO_CLR;
+	u32 mask = get_mask(offset);
+
+	regmap_write_bits(pctl->stmfx->map, reg + get_reg(offset),
+			  mask, mask);
+}
+
+static int stmfx_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);
+	u32 mask = get_mask(offset);
+	u32 val;
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &val);
+	/*
+	 * On stmfx, gpio pins direction is (0)input, (1)output.
+	 * .get_direction returns 0=out, 1=in
+	 */
+
+	return ret ? ret : !(val & mask);
+}
+
+static int stmfx_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, 0);
+}
+
+static int stmfx_gpio_direction_output(struct gpio_chip *gc,
+				       unsigned int offset, int value)
+{
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gc);
+	u32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	stmfx_gpio_set(gc, offset, value);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, mask);
+}
+
+static int stmfx_pinconf_get_pupd(struct stmfx_pinctrl *pctl,
+				  unsigned int offset)
+{
+	u32 reg = STMFX_REG_GPIO_PUPD + get_reg(offset);
+	u32 pupd, mask = get_mask(offset);
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &pupd);
+	if (ret)
+		return ret;
+
+	return !!(pupd & mask);
+}
+
+static int stmfx_pinconf_set_pupd(struct stmfx_pinctrl *pctl,
+				  unsigned int offset, u32 pupd)
+{
+	u32 reg = STMFX_REG_GPIO_PUPD + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, pupd ? mask : 0);
+}
+
+static int stmfx_pinconf_get_type(struct stmfx_pinctrl *pctl,
+				  unsigned int offset)
+{
+	u32 reg = STMFX_REG_GPIO_TYPE + get_reg(offset);
+	u32 type, mask = get_mask(offset);
+	int ret;
+
+	ret = regmap_read(pctl->stmfx->map, reg, &type);
+	if (ret)
+		return ret;
+
+	return !!(type & mask);
+}
+
+static int stmfx_pinconf_set_type(struct stmfx_pinctrl *pctl,
+				  unsigned int offset, u32 type)
+{
+	u32 reg = STMFX_REG_GPIO_TYPE + get_reg(offset);
+	u32 mask = get_mask(offset);
+
+	return regmap_write_bits(pctl->stmfx->map, reg, mask, type ? mask : 0);
+}
+
+static int stmfx_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned int pin, unsigned long *config)
+{
+	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	u32 param = pinconf_to_config_param(*config);
+	struct pinctrl_gpio_range *range;
+	u32 dir, type, pupd;
+	u32 arg = 0;
+	int ret;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
+	if (!range)
+		return -EINVAL;
+
+	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);
+	if (dir < 0)
+		return dir;
+	type = stmfx_pinconf_get_type(pctl, pin);
+	if (type < 0)
+		return type;
+	pupd = stmfx_pinconf_get_pupd(pctl, pin);
+	if (pupd < 0)
+		return pupd;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_DISABLE:
+		if ((!dir && (!type || !pupd)) || (dir && !type))
+			arg = 1;
+		break;
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		if (dir && type && !pupd)
+			arg = 1;
+		break;
+	case PIN_CONFIG_BIAS_PULL_UP:
+		if (type && pupd)
+			arg = 1;
+		break;
+	case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+		if ((!dir && type) || (dir && !type))
+			arg = 1;
+		break;
+	case PIN_CONFIG_DRIVE_PUSH_PULL:
+		if ((!dir && !type) || (dir && type))
+			arg = 1;
+		break;
+	case PIN_CONFIG_OUTPUT:
+		if (dir)
+			return -EINVAL;
+
+		ret = stmfx_gpio_get(&pctl->gpio_chip, pin);
+		if (ret < 0)
+			return ret;
+
+		arg = ret;
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, arg);
+
+	return 0;
+}
+
+static int stmfx_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
+			     unsigned long *configs, unsigned int num_configs)
+{
+	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct pinctrl_gpio_range *range;
+	enum pin_config_param param;
+	u32 arg;
+	int dir, i, ret;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
+	if (!range) {
+		dev_err(pctldev->dev, "pin %d is not available\n", pin);
+		return -EINVAL;
+	}
+
+	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);
+	if (dir < 0)
+		return dir;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+		case PIN_CONFIG_BIAS_DISABLE:
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			ret = stmfx_pinconf_set_pupd(pctl, pin, 0);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+			ret = stmfx_pinconf_set_pupd(pctl, pin, 1);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_DRIVE_OPEN_DRAIN:
+			if (!dir)
+				ret = stmfx_pinconf_set_type(pctl, pin, 1);
+			else
+				ret = stmfx_pinconf_set_type(pctl, pin, 0);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_DRIVE_PUSH_PULL:
+			if (!dir)
+				ret = stmfx_pinconf_set_type(pctl, pin, 0);
+			else
+				ret = stmfx_pinconf_set_type(pctl, pin, 1);
+			if (ret)
+				return ret;
+			break;
+		case PIN_CONFIG_OUTPUT:
+			ret = stmfx_gpio_direction_output(&pctl->gpio_chip,
+							  pin, arg);
+			if (ret)
+				return ret;
+			break;
+		default:
+			return -ENOTSUPP;
+		}
+	}
+
+	return 0;
+}
+
+static void stmfx_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				   struct seq_file *s, unsigned int offset)
+{
+	struct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct pinctrl_gpio_range *range;
+	int dir, type, pupd, val;
+
+	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, offset);
+	if (!range)
+		return;
+
+	dir = stmfx_gpio_get_direction(&pctl->gpio_chip, offset);
+	if (dir < 0)
+		return;
+	type = stmfx_pinconf_get_type(pctl, offset);
+	if (type < 0)
+		return;
+	pupd = stmfx_pinconf_get_pupd(pctl, offset);
+	if (pupd < 0)
+		return;
+	val = stmfx_gpio_get(&pctl->gpio_chip, offset);
+	if (val < 0)
+		return;
+
+	if (!dir) {
+		seq_printf(s, "output %s ", val ? "high" : "low");
+		if (type)
+			seq_printf(s, "open drain %s internal pull-up ",
+				   pupd ? "with" : "without");
+		else
+			seq_puts(s, "push pull no pull ");
+	} else {
+		seq_printf(s, "input %s ", val ? "high" : "low");
+		if (type)
+			seq_printf(s, "with internal pull-%s ",
+				   pupd ? "up" : "down");
+		else
+			seq_printf(s, "%s ", pupd ? "floating" : "analog");
+	}
+}
+
+static const struct pinconf_ops stmfx_pinconf_ops = {
+	.pin_config_get		= stmfx_pinconf_get,
+	.pin_config_set		= stmfx_pinconf_set,
+	.pin_config_dbg_show	= stmfx_pinconf_dbg_show,
+};
+
+static int stmfx_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return 0;
+}
+
+static const char *stmfx_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+						unsigned int selector)
+{
+	return NULL;
+}
+
+static int stmfx_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					unsigned int selector,
+					const unsigned int **pins,
+					unsigned int *num_pins)
+{
+	return -ENOTSUPP;
+}
+
+static const struct pinctrl_ops stmfx_pinctrl_ops = {
+	.get_groups_count = stmfx_pinctrl_get_groups_count,
+	.get_group_name = stmfx_pinctrl_get_group_name,
+	.get_group_pins = stmfx_pinctrl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+static void stmfx_pinctrl_irq_mask(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	pctl->irq_gpi_src[reg] &= ~mask;
+}
+
+static void stmfx_pinctrl_irq_unmask(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	pctl->irq_gpi_src[reg] |= mask;
+}
+
+static int stmfx_pinctrl_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	if (type & IRQ_TYPE_NONE)
+		return -EINVAL;
+
+	if (type & IRQ_TYPE_EDGE_BOTH) {
+		pctl->irq_gpi_evt[reg] |= mask;
+		irq_set_handler_locked(data, handle_edge_irq);
+	} else {
+		pctl->irq_gpi_evt[reg] &= ~mask;
+		irq_set_handler_locked(data, handle_level_irq);
+	}
+
+	if ((type & IRQ_TYPE_EDGE_RISING) || (type & IRQ_TYPE_LEVEL_HIGH))
+		pctl->irq_gpi_type[reg] |= mask;
+	else
+		pctl->irq_gpi_type[reg] &= ~mask;
+
+	/*
+	 * In case of (type & IRQ_TYPE_EDGE_BOTH), we need to know current
+	 * GPIO value to set the right edge trigger. But in atomic context
+	 * here we can't access registers over I2C. That's why (type &
+	 * IRQ_TYPE_EDGE_BOTH) will be managed in .irq_sync_unlock.
+	 */
+
+	if ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)
+		pctl->irq_toggle_edge[reg] |= mask;
+	else
+		pctl->irq_toggle_edge[reg] &= mask;
+
+	return 0;
+}
+
+static void stmfx_pinctrl_irq_bus_lock(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+
+	mutex_lock(&pctl->lock);
+}
+
+static void stmfx_pinctrl_irq_bus_sync_unlock(struct irq_data *data)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	u32 reg = get_reg(data->hwirq);
+	u32 mask = get_mask(data->hwirq);
+
+	/*
+	 * In case of IRQ_TYPE_EDGE_BOTH), read the current GPIO value
+	 * (this couldn't be done in .irq_set_type because of atomic context)
+	 * to set the right irq trigger type.
+	 */
+	if (pctl->irq_toggle_edge[reg] & mask) {
+		if (stmfx_gpio_get(gpio_chip, data->hwirq))
+			pctl->irq_gpi_type[reg] &= ~mask;
+		else
+			pctl->irq_gpi_type[reg] |= mask;
+	}
+
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_EVT,
+			  pctl->irq_gpi_evt, NR_GPIO_REGS);
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_TYPE,
+			  pctl->irq_gpi_type, NR_GPIO_REGS);
+	regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,
+			  pctl->irq_gpi_src, NR_GPIO_REGS);
+
+	mutex_unlock(&pctl->lock);
+}
+
+static void stmfx_pinctrl_irq_toggle_trigger(struct stmfx_pinctrl *pctl,
+					     unsigned int offset)
+{
+	u32 reg = get_reg(offset);
+	u32 mask = get_mask(offset);
+	int val;
+
+	if (!(pctl->irq_toggle_edge[reg] & mask))
+		return;
+
+	val = stmfx_gpio_get(&pctl->gpio_chip, offset);
+	if (val < 0)
+		return;
+
+	if (val) {
+		pctl->irq_gpi_type[reg] &= mask;
+		regmap_write_bits(pctl->stmfx->map,
+				  STMFX_REG_IRQ_GPI_TYPE + reg,
+				  mask, 0);
+
+	} else {
+		pctl->irq_gpi_type[reg] |= mask;
+		regmap_write_bits(pctl->stmfx->map,
+				  STMFX_REG_IRQ_GPI_TYPE + reg,
+				  mask, mask);
+	}
+}
+
+static irqreturn_t stmfx_pinctrl_irq_thread_fn(int irq, void *dev_id)
+{
+	struct stmfx_pinctrl *pctl = (struct stmfx_pinctrl *)dev_id;
+	struct gpio_chip *gc = &pctl->gpio_chip;
+	u8 pending[NR_GPIO_REGS];
+	unsigned long n, status;
+	int ret;
+
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_IRQ_GPI_PENDING,
+			       &pending, NR_GPIO_REGS);
+	if (ret)
+		return IRQ_NONE;
+
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_ACK,
+				pending, NR_GPIO_REGS);
+	if (ret)
+		return IRQ_NONE;
+
+	status = *(unsigned long *)pending;
+	for_each_set_bit(n, &status, gc->ngpio) {
+		handle_nested_irq(irq_find_mapping(gc->irq.domain, n));
+		stmfx_pinctrl_irq_toggle_trigger(pctl, n);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int stmfx_pinctrl_gpio_function_enable(struct stmfx_pinctrl *pctl)
+{
+	struct pinctrl_gpio_range *gpio_range;
+	struct pinctrl_dev *pctl_dev = pctl->pctl_dev;
+	u32 func = STMFX_FUNC_GPIO;
+
+	pctl->gpio_valid_mask = GENMASK(15, 0);
+
+	gpio_range = pinctrl_find_gpio_range_from_pin(pctl_dev, 16);
+	if (gpio_range) {
+		func |= STMFX_FUNC_ALTGPIO_LOW;
+		pctl->gpio_valid_mask |= GENMASK(19, 16);
+	}
+
+	gpio_range = pinctrl_find_gpio_range_from_pin(pctl_dev, 20);
+	if (gpio_range) {
+		func |= STMFX_FUNC_ALTGPIO_HIGH;
+		pctl->gpio_valid_mask |= GENMASK(23, 20);
+	}
+
+	return stmfx_function_enable(pctl->stmfx, func);
+}
+
+static int stmfx_pinctrl_probe(struct platform_device *pdev)
+{
+	struct stmfx *stmfx = dev_get_platdata(&pdev->dev);
+	struct device_node *np = pdev->dev.of_node;
+	struct stmfx_pinctrl *pctl;
+	u32 n;
+	int irq, ret;
+
+	pctl = devm_kzalloc(stmfx->dev, sizeof(*pctl), GFP_KERNEL);
+	if (!pctl)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pctl);
+
+	pctl->dev = &pdev->dev;
+	pctl->stmfx = stmfx;
+
+	if (!of_find_property(np, "gpio-ranges", NULL)) {
+		dev_err(pctl->dev, "missing required gpio-ranges property\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(pctl->dev, "failed to get irq\n");
+		return -ENXIO;
+	}
+
+	mutex_init(&pctl->lock);
+
+	/* Register pin controller */
+	pctl->pctl_desc.name = "stmfx-pinctrl";
+	pctl->pctl_desc.pctlops = &stmfx_pinctrl_ops;
+	pctl->pctl_desc.confops = &stmfx_pinconf_ops;
+	pctl->pctl_desc.pins = stmfx_pins;
+	pctl->pctl_desc.npins = ARRAY_SIZE(stmfx_pins);
+	pctl->pctl_desc.owner = THIS_MODULE;
+
+	ret = devm_pinctrl_register_and_init(pctl->dev, &pctl->pctl_desc,
+					     pctl, &pctl->pctl_dev);
+	if (ret) {
+		dev_err(pctl->dev, "pinctrl registration failed\n");
+		return ret;
+	}
+
+	ret = pinctrl_enable(pctl->pctl_dev);
+	if (ret) {
+		dev_err(pctl->dev, "pinctrl enable failed\n");
+		return ret;
+	}
+
+	/* Register gpio controller */
+	pctl->gpio_chip.label = "stmfx-gpio";
+	pctl->gpio_chip.parent = pctl->dev;
+	pctl->gpio_chip.get_direction = stmfx_gpio_get_direction;
+	pctl->gpio_chip.direction_input = stmfx_gpio_direction_input;
+	pctl->gpio_chip.direction_output = stmfx_gpio_direction_output;
+	pctl->gpio_chip.get = stmfx_gpio_get;
+	pctl->gpio_chip.set = stmfx_gpio_set;
+	pctl->gpio_chip.set_config = gpiochip_generic_config;
+	pctl->gpio_chip.base = -1;
+	pctl->gpio_chip.ngpio = pctl->pctl_desc.npins;
+	pctl->gpio_chip.can_sleep = true;
+	pctl->gpio_chip.of_node = np;
+	pctl->gpio_chip.need_valid_mask = true;
+
+	ret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);
+	if (ret) {
+		dev_err(pctl->dev, "gpio_chip registration failed\n");
+		return ret;
+	}
+
+	ret = stmfx_pinctrl_gpio_function_enable(pctl);
+	if (ret)
+		return ret;
+
+	pctl->irq_chip.name = dev_name(pctl->dev);
+	pctl->irq_chip.irq_mask = stmfx_pinctrl_irq_mask;
+	pctl->irq_chip.irq_unmask = stmfx_pinctrl_irq_unmask;
+	pctl->irq_chip.irq_set_type = stmfx_pinctrl_irq_set_type;
+	pctl->irq_chip.irq_bus_lock = stmfx_pinctrl_irq_bus_lock;
+	pctl->irq_chip.irq_bus_sync_unlock = stmfx_pinctrl_irq_bus_sync_unlock;
+	for_each_clear_bit(n, &pctl->gpio_valid_mask, pctl->gpio_chip.ngpio)
+		clear_bit(n, pctl->gpio_chip.valid_mask);
+
+	ret = gpiochip_irqchip_add_nested(&pctl->gpio_chip, &pctl->irq_chip,
+					  0, handle_bad_irq, IRQ_TYPE_NONE);
+	if (ret) {
+		dev_err(pctl->dev, "cannot add irqchip to gpiochip\n");
+		return ret;
+	}
+
+	ret = devm_request_threaded_irq(pctl->dev, irq, NULL,
+					stmfx_pinctrl_irq_thread_fn,
+					IRQF_ONESHOT,
+					pctl->irq_chip.name, pctl);
+	if (ret) {
+		dev_err(pctl->dev, "cannot request irq%d\n", irq);
+		return ret;
+	}
+
+	gpiochip_set_nested_irqchip(&pctl->gpio_chip, &pctl->irq_chip, irq);
+
+	dev_info(pctl->dev,
+		 "%ld GPIOs available\n", hweight_long(pctl->gpio_valid_mask));
+
+	return 0;
+}
+
+static int stmfx_pinctrl_remove(struct platform_device *pdev)
+{
+	struct stmfx *stmfx = dev_get_platdata(&pdev->dev);
+
+	return stmfx_function_disable(stmfx,
+				      STMFX_FUNC_GPIO |
+				      STMFX_FUNC_ALTGPIO_LOW |
+				      STMFX_FUNC_ALTGPIO_HIGH);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int stmfx_pinctrl_backup_regs(struct stmfx_pinctrl *pctl)
+{
+	int ret;
+
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_STATE,
+			       &pctl->bkp_gpio_state, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_DIR,
+			       &pctl->bkp_gpio_dir, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_TYPE,
+			       &pctl->bkp_gpio_type, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_PUPD,
+			       &pctl->bkp_gpio_pupd, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stmfx_pinctrl_restore_regs(struct stmfx_pinctrl *pctl)
+{
+	int ret;
+
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_DIR,
+				pctl->bkp_gpio_dir, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_TYPE,
+				pctl->bkp_gpio_type, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_PUPD,
+				pctl->bkp_gpio_pupd, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPO_SET,
+				pctl->bkp_gpio_state, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_EVT,
+				pctl->irq_gpi_evt, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_TYPE,
+				pctl->irq_gpi_type, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+	ret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,
+				pctl->irq_gpi_src, NR_GPIO_REGS);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stmfx_pinctrl_suspend(struct device *dev)
+{
+	struct stmfx_pinctrl *pctl = dev_get_drvdata(dev);
+	int ret;
+
+	ret = stmfx_pinctrl_backup_regs(pctl);
+	if (ret) {
+		dev_err(pctl->dev, "registers backup failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stmfx_pinctrl_resume(struct device *dev)
+{
+	struct stmfx_pinctrl *pctl = dev_get_drvdata(dev);
+	int ret;
+
+	ret = stmfx_pinctrl_restore_regs(pctl);
+	if (ret) {
+		dev_err(pctl->dev, "registers restoration failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(stmfx_pinctrl_dev_pm_ops,
+			 stmfx_pinctrl_suspend, stmfx_pinctrl_resume);
+
+static const struct of_device_id stmfx_pinctrl_of_match[] = {
+	{ .compatible = "st,stmfx-0300-pinctrl", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stmfx_pinctrl_of_match);
+
+static struct platform_driver stmfx_pinctrl_driver = {
+	.driver = {
+		.name = "stmfx-pinctrl",
+		.of_match_table = stmfx_pinctrl_of_match,
+		.pm = &stmfx_pinctrl_dev_pm_ops,
+	},
+	.probe = stmfx_pinctrl_probe,
+	.remove = stmfx_pinctrl_remove,
+};
+module_platform_driver(stmfx_pinctrl_driver);
+
+MODULE_DESCRIPTION("STMFX pinctrl/GPIO driver");
+MODULE_AUTHOR("Amelie Delaunay <amelie.delaunay@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32.c b/drivers/pinctrl/stm32/pinctrl-stm32.c
index a9bec6e..e25917f 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32.c
@@ -31,6 +31,7 @@
 #include "../pinconf.h"
 #include "../pinctrl-utils.h"
 #include "pinctrl-stm32.h"
+#include "../pinmux.h"
 
 #define STM32_GPIO_MODER	0x00
 #define STM32_GPIO_TYPER	0x04
@@ -43,6 +44,18 @@
 #define STM32_GPIO_AFRL		0x20
 #define STM32_GPIO_AFRH		0x24
 
+/* custom bitfield to backup pin status */
+#define STM32_GPIO_BKP_MODE_SHIFT		0
+#define STM32_GPIO_BKP_MODE_MASK	GENMASK(1, 0)
+#define STM32_GPIO_BKP_ALT_SHIFT		2
+#define STM32_GPIO_BKP_ALT_MASK		GENMASK(5, 2)
+#define STM32_GPIO_BKP_SPEED_SHIFT		6
+#define STM32_GPIO_BKP_SPEED_MASK	GENMASK(7, 6)
+#define STM32_GPIO_BKP_PUPD_SHIFT		8
+#define STM32_GPIO_BKP_PUPD_MASK	GENMASK(9, 8)
+#define STM32_GPIO_BKP_TYPE		10
+#define STM32_GPIO_BKP_VAL		11
+
 #define STM32_GPIO_PINS_PER_BANK 16
 #define STM32_GPIO_IRQ_LINE	 16
 
@@ -76,6 +89,9 @@ struct stm32_gpio_bank {
 	struct irq_domain *domain;
 	u32 bank_nr;
 	u32 bank_ioport_nr;
+#ifdef CONFIG_PM
+	u32 pin_backup[STM32_GPIO_PINS_PER_BANK];
+#endif
 };
 
 struct stm32_pinctrl {
@@ -91,6 +107,10 @@ struct stm32_pinctrl {
 	struct irq_domain	*domain;
 	struct regmap		*regmap;
 	struct regmap_field	*irqmux[STM32_GPIO_PINS_PER_BANK];
+	struct stm32_desc_pin *pins;
+	u32 npins;
+	u32 pkg;
+	u32 pin_base_shift;
 };
 
 static inline int stm32_gpio_pin(int gpio)
@@ -131,6 +151,8 @@ static inline u32 stm32_gpio_get_alt(u32 function)
 static inline void __stm32_gpio_set(struct stm32_gpio_bank *bank,
 	unsigned offset, int value)
 {
+	stm32_gpio_backup_value(bank, offset, value);
+
 	if (!value)
 		offset += STM32_GPIO_PINS_PER_BANK;
 
@@ -352,16 +374,16 @@ stm32_pctrl_find_group_by_pin(struct stm32_pinctrl *pctl, u32 pin)
 static bool stm32_pctrl_is_function_valid(struct stm32_pinctrl *pctl,
 		u32 pin_num, u32 fnum)
 {
-	int i;
+	int i, k;
 
-	for (i = 0; i < pctl->match_data->npins; i++) {
-		const struct stm32_desc_pin *pin = pctl->match_data->pins + i;
+	for (i = 0; i < pctl->npins; i++) {
+		const struct stm32_desc_pin *pin = pctl->pins + i;
 		const struct stm32_desc_function *func = pin->functions;
 
 		if (pin->pin.number != pin_num)
 			continue;
 
-		while (func && func->name) {
+		for (k = 0; k < STM32_CONFIG_NUM; k++) {
 			if (func->num == fnum)
 				return true;
 			func++;
@@ -594,6 +616,8 @@ static void stm32_pmx_set_mode(struct stm32_gpio_bank *bank,
 	val |= mode << (pin * 2);
 	writel_relaxed(val, bank->base + STM32_GPIO_MODER);
 
+	stm32_gpio_backup_mode(bank, pin, mode, alt);
+
 	spin_unlock_irqrestore(&bank->lock, flags);
 	clk_disable(bank->clk);
 }
@@ -694,6 +718,8 @@ static void stm32_pconf_set_driving(struct stm32_gpio_bank *bank,
 	val |= drive << offset;
 	writel_relaxed(val, bank->base + STM32_GPIO_TYPER);
 
+	stm32_gpio_backup_driving(bank, offset, drive);
+
 	spin_unlock_irqrestore(&bank->lock, flags);
 	clk_disable(bank->clk);
 }
@@ -730,6 +756,8 @@ static void stm32_pconf_set_speed(struct stm32_gpio_bank *bank,
 	val |= speed << (offset * 2);
 	writel_relaxed(val, bank->base + STM32_GPIO_SPEEDR);
 
+	stm32_gpio_backup_speed(bank, offset, speed);
+
 	spin_unlock_irqrestore(&bank->lock, flags);
 	clk_disable(bank->clk);
 }
@@ -766,6 +794,8 @@ static void stm32_pconf_set_bias(struct stm32_gpio_bank *bank,
 	val |= bias << (offset * 2);
 	writel_relaxed(val, bank->base + STM32_GPIO_PUPDR);
 
+	stm32_gpio_backup_bias(bank, offset, bias);
+
 	spin_unlock_irqrestore(&bank->lock, flags);
 	clk_disable(bank->clk);
 }
@@ -893,6 +923,8 @@ static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 				 struct seq_file *s,
 				 unsigned int pin)
 {
+	struct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct stm32_desc_pin *pin_desc;
 	struct pinctrl_gpio_range *range;
 	struct stm32_gpio_bank *bank;
 	int offset;
@@ -942,7 +974,9 @@ static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 	case 2:
 		drive = stm32_pconf_get_driving(bank, offset);
 		speed = stm32_pconf_get_speed(bank, offset);
-		seq_printf(s, "%d - %s - %s - %s %s", alt,
+		pin_desc = pctl->pins + (pin - pctl->pin_base_shift);
+		seq_printf(s, "%d (%s) - %s - %s - %s %s", alt,
+			   pin_desc->functions[alt + 1].name,
 			   drive ? "open drain" : "push pull",
 			   biasing[bias],
 			   speeds[speed], "speed");
@@ -1105,7 +1139,7 @@ static int stm32_pctrl_build_state(struct platform_device *pdev)
 	struct stm32_pinctrl *pctl = platform_get_drvdata(pdev);
 	int i;
 
-	pctl->ngroups = pctl->match_data->npins;
+	pctl->ngroups = pctl->npins;
 
 	/* Allocate groups */
 	pctl->groups = devm_kcalloc(&pdev->dev, pctl->ngroups,
@@ -1119,19 +1153,51 @@ static int stm32_pctrl_build_state(struct platform_device *pdev)
 	if (!pctl->grp_names)
 		return -ENOMEM;
 
-	for (i = 0; i < pctl->match_data->npins; i++) {
-		const struct stm32_desc_pin *pin = pctl->match_data->pins + i;
+	for (i = 0; i < pctl->npins; i++) {
+		const struct stm32_desc_pin *pin = pctl->pins + i;
 		struct stm32_pinctrl_group *group = pctl->groups + i;
 
 		group->name = pin->pin.name;
 		group->pin = pin->pin.number;
-
 		pctl->grp_names[i] = pin->pin.name;
 	}
 
 	return 0;
 }
 
+static int stm32_pctrl_create_pins_tab(struct stm32_pinctrl *pctl,
+				       struct stm32_desc_pin *pins)
+{
+	const struct stm32_desc_pin *p;
+	int i, nb_pins_available = 0;
+
+	for (i = 0; i < pctl->match_data->npins; i++) {
+		p = pctl->match_data->pins + i;
+		if (pctl->pkg && !(pctl->pkg & p->pkg))
+			continue;
+		pins->pin = p->pin;
+		memcpy((struct stm32_desc_pin *)pins->functions, p->functions,
+		       STM32_CONFIG_NUM * sizeof(struct stm32_desc_function));
+		pins++;
+		nb_pins_available++;
+	}
+
+	pctl->npins = nb_pins_available;
+
+	return 0;
+}
+
+static void stm32_pctl_get_package(struct device_node *np,
+				   struct stm32_pinctrl *pctl)
+{
+	if (of_property_read_u32(np, "st,package", &pctl->pkg)) {
+		pctl->pkg = 0;
+		dev_warn(pctl->dev, "No package detected, use default one\n");
+	} else {
+		dev_dbg(pctl->dev, "package detected: %x\n", pctl->pkg);
+	}
+}
+
 int stm32_pctl_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -1162,6 +1228,19 @@ int stm32_pctl_probe(struct platform_device *pdev)
 
 	pctl->dev = dev;
 	pctl->match_data = match->data;
+
+	/*  get package information */
+	stm32_pctl_get_package(np, pctl);
+
+	pctl->pins = devm_kcalloc(pctl->dev, pctl->match_data->npins,
+				  sizeof(*pctl->pins), GFP_KERNEL);
+	if (!pctl->pins)
+		return -ENOMEM;
+
+	ret = stm32_pctrl_create_pins_tab(pctl, pctl->pins);
+	if (ret)
+		return ret;
+
 	ret = stm32_pctrl_build_state(pdev);
 	if (ret) {
 		dev_err(dev, "build state failed: %d\n", ret);
@@ -1174,22 +1253,23 @@ int stm32_pctl_probe(struct platform_device *pdev)
 			return ret;
 	}
 
-	pins = devm_kcalloc(&pdev->dev, pctl->match_data->npins, sizeof(*pins),
+	pins = devm_kcalloc(&pdev->dev, pctl->npins, sizeof(*pins),
 			    GFP_KERNEL);
 	if (!pins)
 		return -ENOMEM;
 
-	for (i = 0; i < pctl->match_data->npins; i++)
-		pins[i] = pctl->match_data->pins[i].pin;
+	for (i = 0; i < pctl->npins; i++)
+		pins[i] = pctl->pins[i].pin;
 
 	pctl->pctl_desc.name = dev_name(&pdev->dev);
 	pctl->pctl_desc.owner = THIS_MODULE;
 	pctl->pctl_desc.pins = pins;
-	pctl->pctl_desc.npins = pctl->match_data->npins;
+	pctl->pctl_desc.npins = pctl->npins;
 	pctl->pctl_desc.confops = &stm32_pconf_ops;
 	pctl->pctl_desc.pctlops = &stm32_pctrl_ops;
 	pctl->pctl_desc.pmxops = &stm32_pmx_ops;
 	pctl->dev = &pdev->dev;
+	pctl->pin_base_shift = pctl->match_data->pin_base_shift;
 
 	pctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->pctl_desc,
 					       pctl);
@@ -1227,3 +1307,100 @@ int stm32_pctl_probe(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+void stm32_gpio_backup_value(struct stm32_gpio_bank *bank,
+			     u32 offset, u32 value)
+{
+	bank->pin_backup[offset] &= ~BIT(STM32_GPIO_BKP_VAL);
+	bank->pin_backup[offset] |= value << STM32_GPIO_BKP_VAL;
+}
+
+void stm32_gpio_backup_mode(struct stm32_gpio_bank *bank,
+			    u32 offset, u32 mode, u32 alt)
+{
+	bank->pin_backup[offset] &= ~(STM32_GPIO_BKP_MODE_MASK |
+				      STM32_GPIO_BKP_ALT_MASK);
+	bank->pin_backup[offset] |= mode << STM32_GPIO_BKP_MODE_SHIFT;
+	bank->pin_backup[offset] |= alt << STM32_GPIO_BKP_ALT_SHIFT;
+}
+
+void stm32_gpio_backup_driving(struct stm32_gpio_bank *bank,
+			       u32 offset, u32 drive)
+{
+	bank->pin_backup[offset] &= ~BIT(STM32_GPIO_BKP_TYPE);
+	bank->pin_backup[offset] |= drive << STM32_GPIO_BKP_TYPE;
+}
+
+void stm32_gpio_backup_speed(struct stm32_gpio_bank *bank,
+			     u32 offset, u32 speed)
+{
+	bank->pin_backup[offset] &= ~STM32_GPIO_BKP_SPEED_MASK;
+	bank->pin_backup[offset] |= speed << STM32_GPIO_BKP_SPEED_SHIFT;
+}
+
+void stm32_gpio_backup_bias(struct stm32_gpio_bank *bank,
+			    u32 offset, u32 bias)
+{
+	bank->pin_backup[offset] &= ~STM32_GPIO_BKP_PUPD_MASK;
+	bank->pin_backup[offset] |= bias << STM32_GPIO_BKP_PUPD_SHIFT;
+}
+
+void stm32_pinctrl_restore_gpio_regs(struct stm32_pinctrl *pctl, u32 pin)
+{
+	const struct pin_desc *desc = pin_desc_get(pctl->pctl_dev, pin);
+	struct pinctrl_gpio_range *range;
+	struct stm32_gpio_bank *bank;
+	u32 val, alt, mode, offset = stm32_gpio_pin(pin);
+	bool pin_is_irq;
+
+	range = pinctrl_find_gpio_range_from_pin(pctl->pctl_dev, pin);
+	if (!range)
+		return;
+
+	pin_is_irq = gpiochip_line_is_irq(range->gc, offset);
+
+	if (!desc || (!pin_is_irq && !desc->gpio_owner))
+		return;
+
+	bank = gpiochip_get_data(range->gc);
+
+	alt = bank->pin_backup[offset] & STM32_GPIO_BKP_ALT_MASK;
+	alt >>= STM32_GPIO_BKP_ALT_SHIFT;
+	mode = bank->pin_backup[offset] & STM32_GPIO_BKP_MODE_MASK;
+	mode >>= STM32_GPIO_BKP_MODE_SHIFT;
+
+	stm32_pmx_set_mode(bank, offset, mode, alt);
+	if (mode == 1) {
+		val = bank->pin_backup[offset] & BIT(STM32_GPIO_BKP_VAL);
+		val = val >> STM32_GPIO_BKP_VAL;
+		__stm32_gpio_set(bank, offset, val);
+	}
+
+	val = bank->pin_backup[offset] & BIT(STM32_GPIO_BKP_TYPE);
+	val >>= STM32_GPIO_BKP_TYPE;
+	stm32_pconf_set_driving(bank, offset, val);
+
+	val = bank->pin_backup[offset] & STM32_GPIO_BKP_SPEED_MASK;
+	val >>= STM32_GPIO_BKP_SPEED_SHIFT;
+	stm32_pconf_set_speed(bank, offset, val);
+
+	val = bank->pin_backup[offset] & STM32_GPIO_BKP_PUPD_MASK;
+	val >>= STM32_GPIO_BKP_PUPD_SHIFT;
+	stm32_pconf_set_bias(bank, offset, val);
+
+	if (pin_is_irq)
+		regmap_field_write(pctl->irqmux[offset], bank->bank_ioport_nr);
+}
+
+int stm32_pinctrl_resume(struct device *dev)
+{
+	struct stm32_pinctrl *pctl = dev_get_drvdata(dev);
+	struct stm32_pinctrl_group *g = pctl->groups;
+	int i;
+
+	for (i = g->pin; i < g->pin + pctl->ngroups; i++)
+		stm32_pinctrl_restore_gpio_regs(pctl, i);
+
+	return 0;
+}
+#endif /*  CONFIG_PM */
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32.h b/drivers/pinctrl/stm32/pinctrl-stm32.h
index 473a623..eb6ed85 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32.h
+++ b/drivers/pinctrl/stm32/pinctrl-stm32.h
@@ -17,6 +17,15 @@
 #define STM32_PIN_GPIO		0
 #define STM32_PIN_AF(x)		((x) + 1)
 #define STM32_PIN_ANALOG	(STM32_PIN_AF(15) + 1)
+#define STM32_CONFIG_NUM	18
+
+/*  package information */
+#define STM32MP157CAA		BIT(0)
+#define STM32MP157CAB		BIT(1)
+#define STM32MP157CAC		BIT(2)
+#define STM32MP157CAD		BIT(3)
+
+#define STM32MP157_Z_BASE_SHIFT	400
 
 struct stm32_desc_function {
 	const char *name;
@@ -25,7 +34,8 @@ struct stm32_desc_function {
 
 struct stm32_desc_pin {
 	struct pinctrl_pin_desc pin;
-	const struct stm32_desc_function *functions;
+	const struct stm32_desc_function functions[STM32_CONFIG_NUM];
+	const unsigned int pkg;
 };
 
 #define STM32_PIN(_pin, ...)					\
@@ -35,8 +45,15 @@ struct stm32_desc_pin {
 			__VA_ARGS__, { } },			\
 	}
 
-#define STM32_FUNCTION(_num, _name)		\
+#define STM32_PIN_PKG(_pin, _pkg, ...)					\
 	{							\
+		.pin = _pin,					\
+		.pkg  = _pkg,				\
+		.functions = {	\
+			__VA_ARGS__},			\
+	}
+#define STM32_FUNCTION(_num, _name)		\
+	[_num] = {						\
 		.num = _num,					\
 		.name = _name,					\
 	}
@@ -44,6 +61,7 @@ struct stm32_desc_pin {
 struct stm32_pinctrl_match_data {
 	const struct stm32_desc_pin *pins;
 	const unsigned int npins;
+	const unsigned int pin_base_shift;
 };
 
 struct stm32_gpio_bank;
@@ -51,5 +69,35 @@ struct stm32_gpio_bank;
 int stm32_pctl_probe(struct platform_device *pdev);
 void stm32_pmx_get_mode(struct stm32_gpio_bank *bank,
 			int pin, u32 *mode, u32 *alt);
+
+#ifdef CONFIG_PM
+void stm32_gpio_backup_value(struct stm32_gpio_bank *bank,
+			     u32 offset, u32 value);
+void stm32_gpio_backup_driving(struct stm32_gpio_bank *bank,
+			       u32 offset, u32 drive);
+void stm32_gpio_backup_speed(struct stm32_gpio_bank *bank,
+			     u32 offset, u32 speed);
+void stm32_gpio_backup_mode(struct stm32_gpio_bank *bank,
+			    u32 offset, u32 mode, u32 alt);
+void stm32_gpio_backup_bias(struct stm32_gpio_bank *bank,
+			    u32 offset, u32 bias);
+int stm32_pinctrl_resume(struct device *dev);
+#else
+static void stm32_gpio_backup_value(struct stm32_gpio_bank *bank,
+				    u32 offset, u32 value)
+{}
+static void stm32_gpio_backup_driving(struct stm32_gpio_bank *bank,
+				      u32 offset, u32 drive)
+{}
+static void stm32_gpio_backup_speed(struct stm32_gpio_bank *bank,
+				    u32 offset, u32 speed)
+{}
+static void stm32_gpio_backup_mode(struct stm32_gpio_bank *bank,
+				   u32 offset, u32 mode, u32 alt)
+{}
+static void stm32_gpio_backup_bias(struct stm32_gpio_bank *bank,
+				   u32 offset, u32 bias)
+{}
+#endif /*  CONFIG_PM */
 #endif /* __PINCTRL_STM32_H */
 
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32mp157.c b/drivers/pinctrl/stm32/pinctrl-stm32mp157.c
index 7c7d628..e1a8a89 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32mp157.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32mp157.c
@@ -10,77 +10,82 @@
 #include "pinctrl-stm32.h"
 
 static const struct stm32_desc_pin stm32mp157_pins[] = {
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(0, "PA0"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA0"),
 		STM32_FUNCTION(2, "TIM2_CH1 TIM2_ETR"),
 		STM32_FUNCTION(3, "TIM5_CH1"),
 		STM32_FUNCTION(4, "TIM8_ETR"),
 		STM32_FUNCTION(5, "TIM15_BKIN"),
-		STM32_FUNCTION(8, "USART2_CTS_NSS USART_BOOT2_CTS_NSS"),
+		STM32_FUNCTION(8, "USART2_CTS USART2_NSS"),
 		STM32_FUNCTION(9, "UART4_TX"),
 		STM32_FUNCTION(10, "SDMMC2_CMD"),
 		STM32_FUNCTION(11, "SAI2_SD_B"),
-		STM32_FUNCTION(12, "ETH_GMII_CRS ETH_MII_CRS"),
+		STM32_FUNCTION(12, "ETH1_GMII_CRS ETH1_MII_CRS"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(1, "PA1"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA1"),
 		STM32_FUNCTION(1, "ETH_CLK"),
 		STM32_FUNCTION(2, "TIM2_CH2"),
 		STM32_FUNCTION(3, "TIM5_CH2"),
 		STM32_FUNCTION(4, "LPTIM3_OUT"),
 		STM32_FUNCTION(5, "TIM15_CH1N"),
-		STM32_FUNCTION(8, "USART2_RTS USART_BOOT2_RTS"),
+		STM32_FUNCTION(8, "USART2_RTS USART2_DE"),
 		STM32_FUNCTION(9, "UART4_RX"),
-		STM32_FUNCTION(10, "QUADSPI_BK1_IO3 QUADSPI_BOOTBK1_IO3"),
+		STM32_FUNCTION(10, "QUADSPI_BK1_IO3"),
 		STM32_FUNCTION(11, "SAI2_MCLK_B"),
-		STM32_FUNCTION(12, "ETH_GMII_RX_CLK ETH_MII_RX_CLK ETH_RGMII_RX_CLK ETH_RMII_REF_CLK"),
+		STM32_FUNCTION(12, "ETH1_GMII_RX_CLK ETH1_MII_RX_CLK ETH1_RGMII_RX_CLK ETH1_RMII_REF_CLK"),
 		STM32_FUNCTION(15, "LCD_R2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(2, "PA2"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA2"),
 		STM32_FUNCTION(2, "TIM2_CH3"),
 		STM32_FUNCTION(3, "TIM5_CH3"),
 		STM32_FUNCTION(4, "LPTIM4_OUT"),
 		STM32_FUNCTION(5, "TIM15_CH1"),
-		STM32_FUNCTION(8, "USART2_TX USART_BOOT2_TX"),
+		STM32_FUNCTION(8, "USART2_TX"),
 		STM32_FUNCTION(9, "SAI2_SCK_B"),
-		STM32_FUNCTION(11, "SDMMC2_D0DIR SDMMC_BOOT2_D0DIR"),
-		STM32_FUNCTION(12, "ETH_MDIO"),
+		STM32_FUNCTION(11, "SDMMC2_D0DIR"),
+		STM32_FUNCTION(12, "ETH1_MDIO"),
 		STM32_FUNCTION(13, "MDIOS_MDIO"),
 		STM32_FUNCTION(15, "LCD_R1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(3, "PA3"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA3"),
 		STM32_FUNCTION(2, "TIM2_CH4"),
 		STM32_FUNCTION(3, "TIM5_CH4"),
 		STM32_FUNCTION(4, "LPTIM5_OUT"),
 		STM32_FUNCTION(5, "TIM15_CH2"),
-		STM32_FUNCTION(8, "USART2_RX USART_BOOT2_RX"),
+		STM32_FUNCTION(8, "USART2_RX"),
 		STM32_FUNCTION(10, "LCD_B2"),
-		STM32_FUNCTION(12, "ETH_GMII_COL ETH_MII_COL"),
+		STM32_FUNCTION(12, "ETH1_GMII_COL ETH1_MII_COL"),
 		STM32_FUNCTION(15, "LCD_B5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(4, "PA4"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA4"),
 		STM32_FUNCTION(1, "HDP0"),
 		STM32_FUNCTION(3, "TIM5_ETR"),
 		STM32_FUNCTION(5, "SAI4_D2"),
 		STM32_FUNCTION(6, "SPI1_NSS I2S1_WS"),
 		STM32_FUNCTION(7, "SPI3_NSS I2S3_WS"),
-		STM32_FUNCTION(8, "USART2_CK USART_BOOT2_CK"),
+		STM32_FUNCTION(8, "USART2_CK"),
 		STM32_FUNCTION(9, "SPI6_NSS"),
 		STM32_FUNCTION(13, "SAI4_FS_A"),
 		STM32_FUNCTION(14, "DCMI_HSYNC"),
@@ -88,8 +93,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(5, "PA5"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA5"),
 		STM32_FUNCTION(2, "TIM2_CH1 TIM2_ETR"),
 		STM32_FUNCTION(4, "TIM8_CH1N"),
@@ -101,8 +107,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(6, "PA6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA6"),
 		STM32_FUNCTION(2, "TIM1_BKIN"),
 		STM32_FUNCTION(3, "TIM3_CH1"),
@@ -118,8 +125,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(7, "PA7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA7"),
 		STM32_FUNCTION(2, "TIM1_CH1N"),
 		STM32_FUNCTION(3, "TIM3_CH2"),
@@ -129,13 +137,14 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(9, "SPI6_MOSI"),
 		STM32_FUNCTION(10, "TIM14_CH1"),
 		STM32_FUNCTION(11, "QUADSPI_CLK"),
-		STM32_FUNCTION(12, "ETH_GMII_RX_DV ETH_MII_RX_DV ETH_RGMII_RX_CTL ETH_RMII_CRS_DV"),
+		STM32_FUNCTION(12, "ETH1_GMII_RX_DV ETH1_MII_RX_DV ETH1_RGMII_RX_CTL ETH1_RMII_CRS_DV"),
 		STM32_FUNCTION(13, "SAI4_SD_A"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(8, "PA8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA8"),
 		STM32_FUNCTION(1, "MCO1"),
 		STM32_FUNCTION(2, "TIM1_CH1"),
@@ -143,37 +152,37 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(5, "I2C3_SCL"),
 		STM32_FUNCTION(6, "SPI3_MOSI I2S3_SDO"),
 		STM32_FUNCTION(8, "USART1_CK"),
-		STM32_FUNCTION(9, "SDMMC2_CKIN SDMMC_BOOT2_CKIN"),
-		STM32_FUNCTION(10, "SDMMC2_D4 SDMMC_BOOT2_D4"),
-		STM32_FUNCTION(11, "USBO_SOF"),
+		STM32_FUNCTION(9, "SDMMC2_CKIN"),
+		STM32_FUNCTION(10, "SDMMC2_D4"),
+		STM32_FUNCTION(11, "OTG_FS_SOF OTG_HS_SOF"),
 		STM32_FUNCTION(13, "SAI4_SD_B"),
 		STM32_FUNCTION(14, "UART7_RX"),
 		STM32_FUNCTION(15, "LCD_R6"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(9, "PA9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA9"),
 		STM32_FUNCTION(2, "TIM1_CH2"),
 		STM32_FUNCTION(5, "I2C3_SMBA"),
 		STM32_FUNCTION(6, "SPI2_SCK I2S2_CK"),
 		STM32_FUNCTION(8, "USART1_TX"),
-		STM32_FUNCTION(9, "SDMMC2_CDIR SDMMC_BOOT2_CDIR"),
-		STM32_FUNCTION(10, "CAN1_RXFD"),
-		STM32_FUNCTION(11, "SDMMC2_D5 SDMMC_BOOT2_D5"),
+		STM32_FUNCTION(9, "SDMMC2_CDIR"),
+		STM32_FUNCTION(11, "SDMMC2_D5"),
 		STM32_FUNCTION(14, "DCMI_D0"),
 		STM32_FUNCTION(15, "LCD_R5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(10, "PA10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA10"),
 		STM32_FUNCTION(2, "TIM1_CH3"),
 		STM32_FUNCTION(6, "SPI3_NSS I2S3_WS"),
 		STM32_FUNCTION(8, "USART1_RX"),
-		STM32_FUNCTION(10, "CAN1_TXFD"),
 		STM32_FUNCTION(12, "MDIOS_MDIO"),
 		STM32_FUNCTION(13, "SAI4_FS_B"),
 		STM32_FUNCTION(14, "DCMI_D1"),
@@ -181,37 +190,39 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(11, "PA11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA11"),
 		STM32_FUNCTION(2, "TIM1_CH4"),
 		STM32_FUNCTION(3, "I2C6_SCL"),
 		STM32_FUNCTION(5, "I2C5_SCL"),
 		STM32_FUNCTION(6, "SPI2_NSS I2S2_WS"),
 		STM32_FUNCTION(7, "UART4_RX"),
-		STM32_FUNCTION(8, "USART1_CTS_NSS"),
-		STM32_FUNCTION(10, "CAN1_RX"),
+		STM32_FUNCTION(8, "USART1_CTS USART1_NSS"),
+		STM32_FUNCTION(10, "FDCAN1_RX"),
 		STM32_FUNCTION(15, "LCD_R4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(12, "PA12"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA12"),
 		STM32_FUNCTION(2, "TIM1_ETR"),
 		STM32_FUNCTION(3, "I2C6_SDA"),
 		STM32_FUNCTION(5, "I2C5_SDA"),
-		STM32_FUNCTION(6, "SPI2_SCK I2S2_CK"),
 		STM32_FUNCTION(7, "UART4_TX"),
-		STM32_FUNCTION(8, "USART1_RTS"),
+		STM32_FUNCTION(8, "USART1_RTS USART1_DE"),
 		STM32_FUNCTION(9, "SAI2_FS_B"),
-		STM32_FUNCTION(10, "CAN1_TX"),
+		STM32_FUNCTION(10, "FDCAN1_TX"),
 		STM32_FUNCTION(15, "LCD_R5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(13, "PA13"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA13"),
 		STM32_FUNCTION(1, "DBTRGO"),
 		STM32_FUNCTION(2, "DBTRGI"),
@@ -220,8 +231,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(14, "PA14"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA14"),
 		STM32_FUNCTION(1, "DBTRGO"),
 		STM32_FUNCTION(2, "DBTRGI"),
@@ -229,73 +241,79 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(15, "PA15"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOA15"),
 		STM32_FUNCTION(1, "DBTRGI"),
 		STM32_FUNCTION(2, "TIM2_CH1 TIM2_ETR"),
 		STM32_FUNCTION(3, "SAI4_D2"),
 		STM32_FUNCTION(4, "SDMMC1_CDIR"),
-		STM32_FUNCTION(5, "HDMI_CEC"),
+		STM32_FUNCTION(5, "CEC"),
 		STM32_FUNCTION(6, "SPI1_NSS I2S1_WS"),
 		STM32_FUNCTION(7, "SPI3_NSS I2S3_WS"),
 		STM32_FUNCTION(8, "SPI6_NSS"),
-		STM32_FUNCTION(9, "UART4_RTS UART_BOOT4_RTS"),
-		STM32_FUNCTION(10, "SDMMC2_D5 SDMMC_BOOT2_D5"),
-		STM32_FUNCTION(11, "SDMMC2_CDIR SDMMC_BOOT2_CDIR"),
-		STM32_FUNCTION(12, "SDMMC1_D5 SDMMC_BOOT1_D5"),
+		STM32_FUNCTION(9, "UART4_RTS UART4_DE"),
+		STM32_FUNCTION(10, "SDMMC2_D5"),
+		STM32_FUNCTION(11, "SDMMC2_CDIR"),
+		STM32_FUNCTION(12, "SDMMC1_D5"),
 		STM32_FUNCTION(13, "SAI4_FS_A"),
 		STM32_FUNCTION(14, "UART7_TX"),
+		STM32_FUNCTION(15, "LCD_R1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(16, "PB0"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB0"),
 		STM32_FUNCTION(2, "TIM1_CH2N"),
 		STM32_FUNCTION(3, "TIM3_CH3"),
 		STM32_FUNCTION(4, "TIM8_CH2N"),
-		STM32_FUNCTION(7, "DFSDM_CKOUT"),
-		STM32_FUNCTION(9, "UART4_CTS UART_BOOT4_CTS"),
+		STM32_FUNCTION(7, "DFSDM1_CKOUT"),
+		STM32_FUNCTION(9, "UART4_CTS"),
 		STM32_FUNCTION(10, "LCD_R3"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD2 ETH_MII_RXD2 ETH_RGMII_RXD2"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD2 ETH1_MII_RXD2 ETH1_RGMII_RXD2"),
 		STM32_FUNCTION(13, "MDIOS_MDIO"),
 		STM32_FUNCTION(15, "LCD_G1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(17, "PB1"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB1"),
 		STM32_FUNCTION(2, "TIM1_CH3N"),
 		STM32_FUNCTION(3, "TIM3_CH4"),
 		STM32_FUNCTION(4, "TIM8_CH3N"),
-		STM32_FUNCTION(7, "DFSDM_DATA1"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN1"),
 		STM32_FUNCTION(10, "LCD_R6"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD3 ETH_MII_RXD3 ETH_RGMII_RXD3"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD3 ETH1_MII_RXD3 ETH1_RGMII_RXD3"),
 		STM32_FUNCTION(13, "MDIOS_MDC"),
 		STM32_FUNCTION(15, "LCD_G0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(18, "PB2"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB2"),
 		STM32_FUNCTION(1, "TRACED4"),
 		STM32_FUNCTION(2, "RTC_OUT2"),
 		STM32_FUNCTION(3, "SAI1_D1"),
-		STM32_FUNCTION(4, "DFSDM_CK1"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN1"),
 		STM32_FUNCTION(5, "USART1_RX"),
 		STM32_FUNCTION(6, "I2S_CKIN"),
 		STM32_FUNCTION(7, "SAI1_SD_A"),
 		STM32_FUNCTION(8, "SPI3_MOSI I2S3_SDO"),
-		STM32_FUNCTION(9, "UART4_RX UART_BOOT4_RX"),
+		STM32_FUNCTION(9, "UART4_RX"),
 		STM32_FUNCTION(10, "QUADSPI_CLK"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(19, "PB3"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB3"),
 		STM32_FUNCTION(1, "TRACED9"),
 		STM32_FUNCTION(2, "TIM2_CH2"),
@@ -303,14 +321,15 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(6, "SPI1_SCK I2S1_CK"),
 		STM32_FUNCTION(7, "SPI3_SCK I2S3_CK"),
 		STM32_FUNCTION(9, "SPI6_SCK"),
-		STM32_FUNCTION(10, "SDMMC2_D2 SDMMC_BOOT2_D2"),
+		STM32_FUNCTION(10, "SDMMC2_D2"),
 		STM32_FUNCTION(13, "SAI4_MCLK_A"),
 		STM32_FUNCTION(14, "UART7_RX"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(20, "PB4"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB4"),
 		STM32_FUNCTION(1, "TRACED8"),
 		STM32_FUNCTION(2, "TIM16_BKIN"),
@@ -320,14 +339,15 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(7, "SPI3_MISO I2S3_SDI"),
 		STM32_FUNCTION(8, "SPI2_NSS I2S2_WS"),
 		STM32_FUNCTION(9, "SPI6_MISO"),
-		STM32_FUNCTION(10, "SDMMC2_D3 SDMMC_BOOT2_D3"),
+		STM32_FUNCTION(10, "SDMMC2_D3"),
 		STM32_FUNCTION(13, "SAI4_SCK_A"),
 		STM32_FUNCTION(14, "UART7_TX"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(21, "PB5"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB5"),
 		STM32_FUNCTION(1, "ETH_CLK"),
 		STM32_FUNCTION(2, "TIM17_BKIN"),
@@ -338,166 +358,175 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(7, "I2C4_SMBA"),
 		STM32_FUNCTION(8, "SPI3_MOSI I2S3_SDO"),
 		STM32_FUNCTION(9, "SPI6_MOSI"),
-		STM32_FUNCTION(10, "CAN2_RX"),
+		STM32_FUNCTION(10, "FDCAN2_RX"),
 		STM32_FUNCTION(11, "SAI4_SD_A"),
-		STM32_FUNCTION(12, "ETH_PPS_OUT"),
-		STM32_FUNCTION(13, "UART5_RX UART_BOOT5_RX"),
+		STM32_FUNCTION(12, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(13, "UART5_RX"),
 		STM32_FUNCTION(14, "DCMI_D10"),
 		STM32_FUNCTION(15, "LCD_G7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(22, "PB6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB6"),
 		STM32_FUNCTION(2, "TIM16_CH1N"),
 		STM32_FUNCTION(3, "TIM4_CH1"),
 		STM32_FUNCTION(5, "I2C1_SCL"),
-		STM32_FUNCTION(6, "HDMI_CEC"),
+		STM32_FUNCTION(6, "CEC"),
 		STM32_FUNCTION(7, "I2C4_SCL"),
 		STM32_FUNCTION(8, "USART1_TX"),
-		STM32_FUNCTION(10, "CAN2_TX"),
-		STM32_FUNCTION(11, "QUADSPI_BK1_NCS QUADSPI_BOOTBK1_NCS"),
-		STM32_FUNCTION(12, "DFSDM_DATA5"),
+		STM32_FUNCTION(10, "FDCAN2_TX"),
+		STM32_FUNCTION(11, "QUADSPI_BK1_NCS"),
+		STM32_FUNCTION(12, "DFSDM1_DATIN5"),
 		STM32_FUNCTION(13, "UART5_TX"),
 		STM32_FUNCTION(14, "DCMI_D5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(23, "PB7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB7"),
 		STM32_FUNCTION(2, "TIM17_CH1N"),
 		STM32_FUNCTION(3, "TIM4_CH2"),
 		STM32_FUNCTION(5, "I2C1_SDA"),
 		STM32_FUNCTION(7, "I2C4_SDA"),
 		STM32_FUNCTION(8, "USART1_RX"),
-		STM32_FUNCTION(10, "CAN2_TXFD"),
-		STM32_FUNCTION(11, "SDMMC2_D1 SDMMC_BOOT2_D1"),
-		STM32_FUNCTION(12, "DFSDM_CK5"),
+		STM32_FUNCTION(11, "SDMMC2_D1"),
+		STM32_FUNCTION(12, "DFSDM1_CKIN5"),
 		STM32_FUNCTION(13, "FMC_NL"),
 		STM32_FUNCTION(14, "DCMI_VSYNC"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(24, "PB8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB8"),
 		STM32_FUNCTION(1, "HDP6"),
 		STM32_FUNCTION(2, "TIM16_CH1"),
 		STM32_FUNCTION(3, "TIM4_CH3"),
-		STM32_FUNCTION(4, "DFSDM_CK7"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN7"),
 		STM32_FUNCTION(5, "I2C1_SCL"),
-		STM32_FUNCTION(6, "SDMMC1_CKIN SDMMC_BOOT1_CKIN"),
+		STM32_FUNCTION(6, "SDMMC1_CKIN"),
 		STM32_FUNCTION(7, "I2C4_SCL"),
-		STM32_FUNCTION(8, "SDMMC2_CKIN SDMMC_BOOT2_CKIN"),
+		STM32_FUNCTION(8, "SDMMC2_CKIN"),
 		STM32_FUNCTION(9, "UART4_RX"),
-		STM32_FUNCTION(10, "CAN1_RX"),
-		STM32_FUNCTION(11, "SDMMC2_D4 SDMMC_BOOT2_D4"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD3 ETH_MII_TXD3 ETH_RGMII_TXD3"),
-		STM32_FUNCTION(13, "SDMMC1_D4 SDMMC_BOOT1_D4"),
+		STM32_FUNCTION(10, "FDCAN1_RX"),
+		STM32_FUNCTION(11, "SDMMC2_D4"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD3 ETH1_MII_TXD3 ETH1_RGMII_TXD3"),
+		STM32_FUNCTION(13, "SDMMC1_D4"),
 		STM32_FUNCTION(14, "DCMI_D6"),
 		STM32_FUNCTION(15, "LCD_B6"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(25, "PB9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB9"),
 		STM32_FUNCTION(1, "HDP7"),
 		STM32_FUNCTION(2, "TIM17_CH1"),
 		STM32_FUNCTION(3, "TIM4_CH4"),
-		STM32_FUNCTION(4, "DFSDM_DATA7"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN7"),
 		STM32_FUNCTION(5, "I2C1_SDA"),
 		STM32_FUNCTION(6, "SPI2_NSS I2S2_WS"),
 		STM32_FUNCTION(7, "I2C4_SDA"),
-		STM32_FUNCTION(8, "SDMMC2_CDIR SDMMC_BOOT2_CDIR"),
+		STM32_FUNCTION(8, "SDMMC2_CDIR"),
 		STM32_FUNCTION(9, "UART4_TX"),
-		STM32_FUNCTION(10, "CAN1_TX"),
-		STM32_FUNCTION(11, "SDMMC2_D5 SDMMC_BOOT2_D5"),
-		STM32_FUNCTION(12, "SDMMC1_CDIR SDMMC_BOOT1_CDIR"),
-		STM32_FUNCTION(13, "SDMMC1_D5 SDMMC_BOOT1_D5"),
+		STM32_FUNCTION(10, "FDCAN1_TX"),
+		STM32_FUNCTION(11, "SDMMC2_D5"),
+		STM32_FUNCTION(12, "SDMMC1_CDIR"),
+		STM32_FUNCTION(13, "SDMMC1_D5"),
 		STM32_FUNCTION(14, "DCMI_D7"),
 		STM32_FUNCTION(15, "LCD_B7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(26, "PB10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB10"),
 		STM32_FUNCTION(2, "TIM2_CH3"),
 		STM32_FUNCTION(4, "LPTIM2_IN1"),
 		STM32_FUNCTION(5, "I2C2_SCL"),
 		STM32_FUNCTION(6, "SPI2_SCK I2S2_CK"),
-		STM32_FUNCTION(7, "DFSDM_DATA7"),
-		STM32_FUNCTION(8, "USART3_TX USART_BOOT3_TX"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN7"),
+		STM32_FUNCTION(8, "USART3_TX"),
 		STM32_FUNCTION(10, "QUADSPI_BK1_NCS"),
-		STM32_FUNCTION(12, "ETH_GMII_RX_ER ETH_MII_RX_ER"),
+		STM32_FUNCTION(12, "ETH1_GMII_RX_ER ETH1_MII_RX_ER"),
 		STM32_FUNCTION(15, "LCD_G4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(27, "PB11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB11"),
 		STM32_FUNCTION(2, "TIM2_CH4"),
 		STM32_FUNCTION(4, "LPTIM2_ETR"),
 		STM32_FUNCTION(5, "I2C2_SDA"),
-		STM32_FUNCTION(7, "DFSDM_CK7"),
+		STM32_FUNCTION(7, "DFSDM1_CKIN7"),
 		STM32_FUNCTION(8, "USART3_RX"),
-		STM32_FUNCTION(12, "ETH_GMII_TX_EN ETH_MII_TX_EN ETH_RGMII_TX_CTL ETH_RMII_TX_EN"),
+		STM32_FUNCTION(12, "ETH1_GMII_TX_EN ETH1_MII_TX_EN ETH1_RGMII_TX_CTL ETH1_RMII_TX_EN"),
 		STM32_FUNCTION(14, "DSI_TE"),
 		STM32_FUNCTION(15, "LCD_G5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(28, "PB12"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB12"),
 		STM32_FUNCTION(2, "TIM1_BKIN"),
 		STM32_FUNCTION(3, "I2C6_SMBA"),
 		STM32_FUNCTION(5, "I2C2_SMBA"),
 		STM32_FUNCTION(6, "SPI2_NSS I2S2_WS"),
-		STM32_FUNCTION(7, "DFSDM_DATA1"),
-		STM32_FUNCTION(8, "USART3_CK USART_BOOT3_CK"),
-		STM32_FUNCTION(9, "USART3_RX USART_BOOT3_RX"),
-		STM32_FUNCTION(10, "CAN2_RX"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD0 ETH_MII_TXD0 ETH_RGMII_TXD0 ETH_RMII_TXD0"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN1"),
+		STM32_FUNCTION(8, "USART3_CK"),
+		STM32_FUNCTION(9, "USART3_RX"),
+		STM32_FUNCTION(10, "FDCAN2_RX"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD0 ETH1_MII_TXD0 ETH1_RGMII_TXD0 ETH1_RMII_TXD0"),
 		STM32_FUNCTION(15, "UART5_RX"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(29, "PB13"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB13"),
 		STM32_FUNCTION(2, "TIM1_CH1N"),
-		STM32_FUNCTION(4, "DFSDM_CKOUT"),
+		STM32_FUNCTION(4, "DFSDM1_CKOUT"),
 		STM32_FUNCTION(5, "LPTIM2_OUT"),
 		STM32_FUNCTION(6, "SPI2_SCK I2S2_CK"),
-		STM32_FUNCTION(7, "DFSDM_CK1"),
-		STM32_FUNCTION(8, "USART3_CTS_NSS USART_BOOT3_CTS_NSS"),
-		STM32_FUNCTION(10, "CAN2_TX"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD1 ETH_MII_TXD1 ETH_RGMII_TXD1 ETH_RMII_TXD1"),
-		STM32_FUNCTION(15, "UART5_TX UART_BOOT5_TX"),
+		STM32_FUNCTION(7, "DFSDM1_CKIN1"),
+		STM32_FUNCTION(8, "USART3_CTS USART3_NSS"),
+		STM32_FUNCTION(10, "FDCAN2_TX"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD1 ETH1_MII_TXD1 ETH1_RGMII_TXD1 ETH1_RMII_TXD1"),
+		STM32_FUNCTION(15, "UART5_TX"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(30, "PB14"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB14"),
 		STM32_FUNCTION(2, "TIM1_CH2N"),
 		STM32_FUNCTION(3, "TIM12_CH1"),
 		STM32_FUNCTION(4, "TIM8_CH2N"),
 		STM32_FUNCTION(5, "USART1_TX"),
 		STM32_FUNCTION(6, "SPI2_MISO I2S2_SDI"),
-		STM32_FUNCTION(7, "DFSDM_DATA2"),
-		STM32_FUNCTION(8, "USART3_RTS USART_BOOT3_RTS"),
-		STM32_FUNCTION(10, "SDMMC2_D0 SDMMC_BOOT2_D0"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN2"),
+		STM32_FUNCTION(8, "USART3_RTS USART3_DE"),
+		STM32_FUNCTION(10, "SDMMC2_D0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(31, "PB15"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOB15"),
 		STM32_FUNCTION(1, "RTC_REFIN"),
 		STM32_FUNCTION(2, "TIM1_CH3N"),
@@ -505,523 +534,557 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(4, "TIM8_CH3N"),
 		STM32_FUNCTION(5, "USART1_RX"),
 		STM32_FUNCTION(6, "SPI2_MOSI I2S2_SDO"),
-		STM32_FUNCTION(7, "DFSDM_CK2"),
-		STM32_FUNCTION(10, "SDMMC2_D1 SDMMC_BOOT2_D1"),
+		STM32_FUNCTION(7, "DFSDM1_CKIN2"),
+		STM32_FUNCTION(10, "SDMMC2_D1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(32, "PC0"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC0"),
-		STM32_FUNCTION(4, "DFSDM_CK0"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN0"),
 		STM32_FUNCTION(5, "LPTIM2_IN2"),
-		STM32_FUNCTION(7, "DFSDM_DATA4"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN4"),
 		STM32_FUNCTION(9, "SAI2_FS_B"),
-		STM32_FUNCTION(11, "QUADSPI_BK2_NCS QUADSPI_BOOTBK2_NCS"),
+		STM32_FUNCTION(11, "QUADSPI_BK2_NCS"),
 		STM32_FUNCTION(15, "LCD_R5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(33, "PC1"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC1"),
 		STM32_FUNCTION(1, "TRACED0"),
 		STM32_FUNCTION(3, "SAI1_D1"),
-		STM32_FUNCTION(4, "DFSDM_DATA0"),
-		STM32_FUNCTION(5, "DFSDM_CK4"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN0"),
+		STM32_FUNCTION(5, "DFSDM1_CKIN4"),
 		STM32_FUNCTION(6, "SPI2_MOSI I2S2_SDO"),
 		STM32_FUNCTION(7, "SAI1_SD_A"),
 		STM32_FUNCTION(10, "SDMMC2_CK"),
-		STM32_FUNCTION(12, "ETH_MDC"),
+		STM32_FUNCTION(12, "ETH1_MDC"),
 		STM32_FUNCTION(13, "MDIOS_MDC"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(34, "PC2"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC2"),
-		STM32_FUNCTION(4, "DFSDM_CK1"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN1"),
 		STM32_FUNCTION(6, "SPI2_MISO I2S2_SDI"),
-		STM32_FUNCTION(7, "DFSDM_CKOUT"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD2 ETH_MII_TXD2 ETH_RGMII_TXD2"),
+		STM32_FUNCTION(7, "DFSDM1_CKOUT"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD2 ETH1_MII_TXD2 ETH1_RGMII_TXD2"),
+		STM32_FUNCTION(14, "DCMI_PIXCLK"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(35, "PC3"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC3"),
 		STM32_FUNCTION(1, "TRACECLK"),
-		STM32_FUNCTION(4, "DFSDM_DATA1"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN1"),
 		STM32_FUNCTION(6, "SPI2_MOSI I2S2_SDO"),
-		STM32_FUNCTION(12, "ETH_GMII_TX_CLK ETH_MII_TX_CLK"),
+		STM32_FUNCTION(12, "ETH1_GMII_TX_CLK ETH1_MII_TX_CLK"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(36, "PC4"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC4"),
-		STM32_FUNCTION(4, "DFSDM_CK2"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN2"),
 		STM32_FUNCTION(6, "I2S1_MCK"),
-		STM32_FUNCTION(10, "SPDIF_IN2"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD0 ETH_MII_RXD0 ETH_RGMII_RXD0 ETH_RMII_RXD0"),
+		STM32_FUNCTION(10, "SPDIFRX_IN2"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD0 ETH1_MII_RXD0 ETH1_RGMII_RXD0 ETH1_RMII_RXD0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(37, "PC5"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC5"),
 		STM32_FUNCTION(3, "SAI1_D3"),
-		STM32_FUNCTION(4, "DFSDM_DATA2"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN2"),
 		STM32_FUNCTION(5, "SAI4_D4"),
 		STM32_FUNCTION(7, "SAI1_D4"),
-		STM32_FUNCTION(10, "SPDIF_IN3"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD1 ETH_MII_RXD1 ETH_RGMII_RXD1 ETH_RMII_RXD1"),
+		STM32_FUNCTION(10, "SPDIFRX_IN3"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD1 ETH1_MII_RXD1 ETH1_RGMII_RXD1 ETH1_RMII_RXD1"),
 		STM32_FUNCTION(13, "SAI4_D3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(38, "PC6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC6"),
 		STM32_FUNCTION(1, "HDP1"),
 		STM32_FUNCTION(3, "TIM3_CH1"),
 		STM32_FUNCTION(4, "TIM8_CH1"),
-		STM32_FUNCTION(5, "DFSDM_CK3"),
+		STM32_FUNCTION(5, "DFSDM1_CKIN3"),
 		STM32_FUNCTION(6, "I2S2_MCK"),
-		STM32_FUNCTION(8, "USART6_TX USART_BOOT6_TX"),
-		STM32_FUNCTION(9, "SDMMC1_D0DIR SDMMC_BOOT1_D0DIR"),
-		STM32_FUNCTION(10, "SDMMC2_D0DIR SDMMC_BOOT2_D0DIR"),
-		STM32_FUNCTION(11, "SDMMC2_D6 SDMMC_BOOT2_D6"),
+		STM32_FUNCTION(8, "USART6_TX"),
+		STM32_FUNCTION(9, "SDMMC1_D0DIR"),
+		STM32_FUNCTION(10, "SDMMC2_D0DIR"),
+		STM32_FUNCTION(11, "SDMMC2_D6"),
 		STM32_FUNCTION(12, "DSI_TE"),
-		STM32_FUNCTION(13, "SDMMC1_D6 SDMMC_BOOT1_D6"),
+		STM32_FUNCTION(13, "SDMMC1_D6"),
 		STM32_FUNCTION(14, "DCMI_D0"),
 		STM32_FUNCTION(15, "LCD_HSYNC"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(39, "PC7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC7"),
 		STM32_FUNCTION(1, "HDP4"),
 		STM32_FUNCTION(3, "TIM3_CH2"),
 		STM32_FUNCTION(4, "TIM8_CH2"),
-		STM32_FUNCTION(5, "DFSDM_DATA3"),
+		STM32_FUNCTION(5, "DFSDM1_DATIN3"),
 		STM32_FUNCTION(7, "I2S3_MCK"),
-		STM32_FUNCTION(8, "USART6_RX USART_BOOT6_RX"),
-		STM32_FUNCTION(9, "SDMMC1_D123DIR SDMMC_BOOT1_D123DIR"),
-		STM32_FUNCTION(10, "SDMMC2_D123DIR SDMMC_BOOT2_D123DIR"),
-		STM32_FUNCTION(11, "SDMMC2_D7 SDMMC_BOOT2_D7"),
-		STM32_FUNCTION(13, "SDMMC1_D7 SDMMC_BOOT1_D7"),
+		STM32_FUNCTION(8, "USART6_RX"),
+		STM32_FUNCTION(9, "SDMMC1_D123DIR"),
+		STM32_FUNCTION(10, "SDMMC2_D123DIR"),
+		STM32_FUNCTION(11, "SDMMC2_D7"),
+		STM32_FUNCTION(13, "SDMMC1_D7"),
 		STM32_FUNCTION(14, "DCMI_D1"),
 		STM32_FUNCTION(15, "LCD_G6"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(40, "PC8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC8"),
 		STM32_FUNCTION(1, "TRACED0"),
 		STM32_FUNCTION(3, "TIM3_CH3"),
 		STM32_FUNCTION(4, "TIM8_CH3"),
 		STM32_FUNCTION(7, "UART4_TX"),
-		STM32_FUNCTION(8, "USART6_CK USART_BOOT6_CK"),
-		STM32_FUNCTION(9, "UART5_RTS UART_BOOT5_RTS"),
-		STM32_FUNCTION(13, "SDMMC1_D0 SDMMC_BOOT1_D0"),
+		STM32_FUNCTION(8, "USART6_CK"),
+		STM32_FUNCTION(9, "UART5_RTS UART5_DE"),
+		STM32_FUNCTION(13, "SDMMC1_D0"),
 		STM32_FUNCTION(14, "DCMI_D2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(41, "PC9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC9"),
 		STM32_FUNCTION(1, "TRACED1"),
 		STM32_FUNCTION(3, "TIM3_CH4"),
 		STM32_FUNCTION(4, "TIM8_CH4"),
 		STM32_FUNCTION(5, "I2C3_SDA"),
 		STM32_FUNCTION(6, "I2S_CKIN"),
-		STM32_FUNCTION(9, "UART5_CTS UART_BOOT5_CTS"),
+		STM32_FUNCTION(9, "UART5_CTS"),
 		STM32_FUNCTION(10, "QUADSPI_BK1_IO0"),
-		STM32_FUNCTION(13, "SDMMC1_D1 SDMMC_BOOT1_D1"),
+		STM32_FUNCTION(13, "SDMMC1_D1"),
 		STM32_FUNCTION(14, "DCMI_D3"),
 		STM32_FUNCTION(15, "LCD_B2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(42, "PC10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC10"),
 		STM32_FUNCTION(1, "TRACED2"),
-		STM32_FUNCTION(4, "DFSDM_CK5"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN5"),
 		STM32_FUNCTION(7, "SPI3_SCK I2S3_CK"),
 		STM32_FUNCTION(8, "USART3_TX"),
 		STM32_FUNCTION(9, "UART4_TX"),
 		STM32_FUNCTION(10, "QUADSPI_BK1_IO1"),
 		STM32_FUNCTION(11, "SAI4_MCLK_B"),
-		STM32_FUNCTION(13, "SDMMC1_D2 SDMMC_BOOT1_D2"),
+		STM32_FUNCTION(13, "SDMMC1_D2"),
 		STM32_FUNCTION(14, "DCMI_D8"),
 		STM32_FUNCTION(15, "LCD_R2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(43, "PC11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC11"),
 		STM32_FUNCTION(1, "TRACED3"),
-		STM32_FUNCTION(4, "DFSDM_DATA5"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN5"),
 		STM32_FUNCTION(7, "SPI3_MISO I2S3_SDI"),
 		STM32_FUNCTION(8, "USART3_RX"),
 		STM32_FUNCTION(9, "UART4_RX"),
-		STM32_FUNCTION(10, "QUADSPI_BK2_NCS QUADSPI_BOOTBK2_NCS"),
+		STM32_FUNCTION(10, "QUADSPI_BK2_NCS"),
 		STM32_FUNCTION(11, "SAI4_SCK_B"),
-		STM32_FUNCTION(13, "SDMMC1_D3 SDMMC_BOOT1_D3"),
+		STM32_FUNCTION(13, "SDMMC1_D3"),
 		STM32_FUNCTION(14, "DCMI_D4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(44, "PC12"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC12"),
 		STM32_FUNCTION(1, "TRACECLK"),
 		STM32_FUNCTION(2, "MCO2"),
 		STM32_FUNCTION(3, "SAI4_D3"),
 		STM32_FUNCTION(7, "SPI3_MOSI I2S3_SDO"),
-		STM32_FUNCTION(8, "USART3_CK USART_BOOT3_CK"),
+		STM32_FUNCTION(8, "USART3_CK"),
 		STM32_FUNCTION(9, "UART5_TX"),
 		STM32_FUNCTION(11, "SAI4_SD_B"),
-		STM32_FUNCTION(13, "SDMMC1_CK SDMMC_BOOT1_CK"),
+		STM32_FUNCTION(13, "SDMMC1_CK"),
 		STM32_FUNCTION(14, "DCMI_D9"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(45, "PC13"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC13"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(46, "PC14"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC14"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(47, "PC15"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOC15"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(48, "PD0"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD0"),
 		STM32_FUNCTION(3, "I2C6_SDA"),
-		STM32_FUNCTION(4, "DFSDM_CK6"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN6"),
 		STM32_FUNCTION(5, "I2C5_SDA"),
 		STM32_FUNCTION(7, "SAI3_SCK_A"),
 		STM32_FUNCTION(9, "UART4_RX"),
-		STM32_FUNCTION(10, "CAN1_RX"),
+		STM32_FUNCTION(10, "FDCAN1_RX"),
 		STM32_FUNCTION(11, "SDMMC3_CMD"),
-		STM32_FUNCTION(12, "DFSDM_DATA7"),
-		STM32_FUNCTION(13, "FMC_D2"),
+		STM32_FUNCTION(12, "DFSDM1_DATIN7"),
+		STM32_FUNCTION(13, "FMC_D2 FMC_DA2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(49, "PD1"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD1"),
 		STM32_FUNCTION(3, "I2C6_SCL"),
-		STM32_FUNCTION(4, "DFSDM_DATA6"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN6"),
 		STM32_FUNCTION(5, "I2C5_SCL"),
 		STM32_FUNCTION(7, "SAI3_SD_A"),
 		STM32_FUNCTION(9, "UART4_TX"),
-		STM32_FUNCTION(10, "CAN1_TX"),
+		STM32_FUNCTION(10, "FDCAN1_TX"),
 		STM32_FUNCTION(11, "SDMMC3_D0"),
-		STM32_FUNCTION(12, "DFSDM_CK7"),
-		STM32_FUNCTION(13, "FMC_D3"),
+		STM32_FUNCTION(12, "DFSDM1_CKIN7"),
+		STM32_FUNCTION(13, "FMC_D3 FMC_DA3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(50, "PD2"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD2"),
 		STM32_FUNCTION(3, "TIM3_ETR"),
 		STM32_FUNCTION(5, "I2C5_SMBA"),
 		STM32_FUNCTION(7, "UART4_RX"),
 		STM32_FUNCTION(9, "UART5_RX"),
-		STM32_FUNCTION(13, "SDMMC1_CMD SDMMC_BOOT1_CMD"),
+		STM32_FUNCTION(13, "SDMMC1_CMD"),
 		STM32_FUNCTION(14, "DCMI_D11"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(51, "PD3"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD3"),
 		STM32_FUNCTION(1, "HDP5"),
-		STM32_FUNCTION(4, "DFSDM_CKOUT"),
+		STM32_FUNCTION(4, "DFSDM1_CKOUT"),
 		STM32_FUNCTION(6, "SPI2_SCK I2S2_CK"),
-		STM32_FUNCTION(7, "DFSDM_DATA0"),
-		STM32_FUNCTION(8, "USART2_CTS_NSS USART_BOOT2_CTS_NSS"),
-		STM32_FUNCTION(9, "SDMMC1_D123DIR SDMMC_BOOT1_D123DIR"),
-		STM32_FUNCTION(10, "SDMMC2_D7 SDMMC_BOOT2_D7"),
-		STM32_FUNCTION(11, "SDMMC2_D123DIR SDMMC_BOOT2_D123DIR"),
-		STM32_FUNCTION(12, "SDMMC1_D7 SDMMC_BOOT1_D7"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN0"),
+		STM32_FUNCTION(8, "USART2_CTS USART2_NSS"),
+		STM32_FUNCTION(9, "SDMMC1_D123DIR"),
+		STM32_FUNCTION(10, "SDMMC2_D7"),
+		STM32_FUNCTION(11, "SDMMC2_D123DIR"),
+		STM32_FUNCTION(12, "SDMMC1_D7"),
 		STM32_FUNCTION(13, "FMC_CLK"),
 		STM32_FUNCTION(14, "DCMI_D5"),
 		STM32_FUNCTION(15, "LCD_G7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(52, "PD4"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD4"),
 		STM32_FUNCTION(7, "SAI3_FS_A"),
-		STM32_FUNCTION(8, "USART2_RTS USART_BOOT2_RTS"),
-		STM32_FUNCTION(10, "CAN1_RXFD"),
+		STM32_FUNCTION(8, "USART2_RTS USART2_DE"),
 		STM32_FUNCTION(11, "SDMMC3_D1"),
-		STM32_FUNCTION(12, "DFSDM_CK0"),
+		STM32_FUNCTION(12, "DFSDM1_CKIN0"),
 		STM32_FUNCTION(13, "FMC_NOE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(53, "PD5"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD5"),
 		STM32_FUNCTION(8, "USART2_TX"),
-		STM32_FUNCTION(10, "CAN1_TXFD"),
 		STM32_FUNCTION(11, "SDMMC3_D2"),
 		STM32_FUNCTION(13, "FMC_NWE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(54, "PD6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD6"),
 		STM32_FUNCTION(2, "TIM16_CH1N"),
 		STM32_FUNCTION(3, "SAI1_D1"),
-		STM32_FUNCTION(4, "DFSDM_CK4"),
-		STM32_FUNCTION(5, "DFSDM_DATA1"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN4"),
+		STM32_FUNCTION(5, "DFSDM1_DATIN1"),
 		STM32_FUNCTION(6, "SPI3_MOSI I2S3_SDO"),
 		STM32_FUNCTION(7, "SAI1_SD_A"),
 		STM32_FUNCTION(8, "USART2_RX"),
-		STM32_FUNCTION(10, "CAN2_RXFD"),
-		STM32_FUNCTION(11, "FMC_INT"),
 		STM32_FUNCTION(13, "FMC_NWAIT"),
 		STM32_FUNCTION(14, "DCMI_D10"),
 		STM32_FUNCTION(15, "LCD_B2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(55, "PD7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD7"),
 		STM32_FUNCTION(1, "TRACED6"),
-		STM32_FUNCTION(4, "DFSDM_DATA4"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN4"),
 		STM32_FUNCTION(5, "I2C2_SCL"),
-		STM32_FUNCTION(7, "DFSDM_CK1"),
-		STM32_FUNCTION(8, "USART2_CK USART_BOOT2_CK"),
-		STM32_FUNCTION(10, "SPDIF_IN0"),
+		STM32_FUNCTION(7, "DFSDM1_CKIN1"),
+		STM32_FUNCTION(8, "USART2_CK"),
+		STM32_FUNCTION(10, "SPDIFRX_IN0"),
 		STM32_FUNCTION(11, "SDMMC3_D3"),
 		STM32_FUNCTION(13, "FMC_NE1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(56, "PD8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD8"),
-		STM32_FUNCTION(4, "DFSDM_CK3"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN3"),
 		STM32_FUNCTION(7, "SAI3_SCK_B"),
 		STM32_FUNCTION(8, "USART3_TX"),
-		STM32_FUNCTION(10, "SPDIF_IN1"),
-		STM32_FUNCTION(13, "FMC_D13"),
+		STM32_FUNCTION(10, "SPDIFRX_IN1"),
+		STM32_FUNCTION(13, "FMC_D13 FMC_DA13"),
 		STM32_FUNCTION(15, "LCD_B7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(57, "PD9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD9"),
-		STM32_FUNCTION(4, "DFSDM_DATA3"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN3"),
 		STM32_FUNCTION(7, "SAI3_SD_B"),
 		STM32_FUNCTION(8, "USART3_RX"),
-		STM32_FUNCTION(10, "CAN2_RXFD"),
-		STM32_FUNCTION(13, "FMC_D14"),
+		STM32_FUNCTION(13, "FMC_D14 FMC_DA14"),
+		STM32_FUNCTION(14, "DCMI_HSYNC"),
 		STM32_FUNCTION(15, "LCD_B0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(58, "PD10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD10"),
 		STM32_FUNCTION(1, "RTC_REFIN"),
 		STM32_FUNCTION(2, "TIM16_BKIN"),
-		STM32_FUNCTION(4, "DFSDM_CKOUT"),
+		STM32_FUNCTION(4, "DFSDM1_CKOUT"),
 		STM32_FUNCTION(5, "I2C5_SMBA"),
 		STM32_FUNCTION(6, "SPI3_MISO I2S3_SDI"),
 		STM32_FUNCTION(7, "SAI3_FS_B"),
-		STM32_FUNCTION(8, "USART3_CK USART_BOOT3_CK"),
-		STM32_FUNCTION(10, "CAN2_TXFD"),
-		STM32_FUNCTION(13, "FMC_D15"),
+		STM32_FUNCTION(8, "USART3_CK"),
+		STM32_FUNCTION(13, "FMC_D15 FMC_DA15"),
 		STM32_FUNCTION(15, "LCD_B3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(59, "PD11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD11"),
 		STM32_FUNCTION(4, "LPTIM2_IN2"),
 		STM32_FUNCTION(5, "I2C4_SMBA"),
 		STM32_FUNCTION(6, "I2C1_SMBA"),
-		STM32_FUNCTION(8, "USART3_CTS_NSS USART_BOOT3_CTS_NSS"),
+		STM32_FUNCTION(8, "USART3_CTS USART3_NSS"),
 		STM32_FUNCTION(10, "QUADSPI_BK1_IO0"),
 		STM32_FUNCTION(11, "SAI2_SD_A"),
-		STM32_FUNCTION(13, "FMC_A16 FMC_CLE"),
+		STM32_FUNCTION(13, "FMC_CLE FMC_A16"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(60, "PD12"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD12"),
 		STM32_FUNCTION(2, "LPTIM1_IN1"),
 		STM32_FUNCTION(3, "TIM4_CH1"),
 		STM32_FUNCTION(4, "LPTIM2_IN1"),
 		STM32_FUNCTION(5, "I2C4_SCL"),
 		STM32_FUNCTION(6, "I2C1_SCL"),
-		STM32_FUNCTION(8, "USART3_RTS USART_BOOT3_RTS"),
+		STM32_FUNCTION(8, "USART3_RTS USART3_DE"),
 		STM32_FUNCTION(10, "QUADSPI_BK1_IO1"),
 		STM32_FUNCTION(11, "SAI2_FS_A"),
-		STM32_FUNCTION(13, "FMC_A17 FMC_ALE"),
+		STM32_FUNCTION(13, "FMC_ALE FMC_A17"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(61, "PD13"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD13"),
 		STM32_FUNCTION(2, "LPTIM1_OUT"),
 		STM32_FUNCTION(3, "TIM4_CH2"),
 		STM32_FUNCTION(5, "I2C4_SDA"),
 		STM32_FUNCTION(6, "I2C1_SDA"),
 		STM32_FUNCTION(7, "I2S3_MCK"),
-		STM32_FUNCTION(10, "QUADSPI_BK1_IO3 QUADSPI_BOOTBK1_IO3"),
+		STM32_FUNCTION(10, "QUADSPI_BK1_IO3"),
 		STM32_FUNCTION(11, "SAI2_SCK_A"),
 		STM32_FUNCTION(13, "FMC_A18"),
 		STM32_FUNCTION(14, "DSI_TE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(62, "PD14"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD14"),
 		STM32_FUNCTION(3, "TIM4_CH3"),
 		STM32_FUNCTION(7, "SAI3_MCLK_B"),
-		STM32_FUNCTION(9, "UART8_CTS UART_BOOT8_CTS"),
-		STM32_FUNCTION(13, "FMC_D0"),
+		STM32_FUNCTION(9, "UART8_CTS"),
+		STM32_FUNCTION(13, "FMC_D0 FMC_DA0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(63, "PD15"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOD15"),
 		STM32_FUNCTION(3, "TIM4_CH4"),
 		STM32_FUNCTION(7, "SAI3_MCLK_A"),
-		STM32_FUNCTION(9, "UART8_CTS UART_BOOT8_CTS"),
-		STM32_FUNCTION(13, "FMC_D1"),
+		STM32_FUNCTION(9, "UART8_CTS"),
+		STM32_FUNCTION(13, "FMC_D1 FMC_DA1"),
+		STM32_FUNCTION(15, "LCD_R1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(64, "PE0"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE0"),
 		STM32_FUNCTION(2, "LPTIM1_ETR"),
 		STM32_FUNCTION(3, "TIM4_ETR"),
 		STM32_FUNCTION(5, "LPTIM2_ETR"),
 		STM32_FUNCTION(6, "SPI3_SCK I2S3_CK"),
 		STM32_FUNCTION(7, "SAI4_MCLK_B"),
-		STM32_FUNCTION(9, "UART8_RX UART_BOOT8_RX"),
-		STM32_FUNCTION(10, "CAN1_RXFD"),
+		STM32_FUNCTION(9, "UART8_RX"),
 		STM32_FUNCTION(11, "SAI2_MCLK_A"),
 		STM32_FUNCTION(13, "FMC_NBL0"),
 		STM32_FUNCTION(14, "DCMI_D2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(65, "PE1"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE1"),
 		STM32_FUNCTION(2, "LPTIM1_IN2"),
 		STM32_FUNCTION(6, "I2S2_MCK"),
 		STM32_FUNCTION(7, "SAI3_SD_B"),
-		STM32_FUNCTION(9, "UART8_TX UART_BOOT8_TX"),
-		STM32_FUNCTION(10, "CAN1_TXFD"),
+		STM32_FUNCTION(9, "UART8_TX"),
 		STM32_FUNCTION(13, "FMC_NBL1"),
 		STM32_FUNCTION(14, "DCMI_D3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(66, "PE2"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE2"),
 		STM32_FUNCTION(1, "TRACECLK"),
 		STM32_FUNCTION(3, "SAI1_CK1"),
 		STM32_FUNCTION(5, "I2C4_SCL"),
 		STM32_FUNCTION(6, "SPI4_SCK"),
 		STM32_FUNCTION(7, "SAI1_MCLK_A"),
-		STM32_FUNCTION(10, "QUADSPI_BK1_IO2 QUADSPI_BOOTBK1_IO2"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD3 ETH_MII_TXD3 ETH_RGMII_TXD3"),
+		STM32_FUNCTION(10, "QUADSPI_BK1_IO2"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD3 ETH1_MII_TXD3 ETH1_RGMII_TXD3"),
 		STM32_FUNCTION(13, "FMC_A23"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(67, "PE3"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE3"),
 		STM32_FUNCTION(1, "TRACED0"),
 		STM32_FUNCTION(5, "TIM15_BKIN"),
 		STM32_FUNCTION(7, "SAI1_SD_B"),
-		STM32_FUNCTION(10, "SDMMC2_CK SDMMC_BOOT2_CK"),
+		STM32_FUNCTION(10, "SDMMC2_CK"),
 		STM32_FUNCTION(13, "FMC_A19"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(68, "PE4"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE4"),
 		STM32_FUNCTION(1, "TRACED1"),
 		STM32_FUNCTION(3, "SAI1_D2"),
-		STM32_FUNCTION(4, "DFSDM_DATA3"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN3"),
 		STM32_FUNCTION(5, "TIM15_CH1N"),
 		STM32_FUNCTION(6, "SPI4_NSS"),
 		STM32_FUNCTION(7, "SAI1_FS_A"),
-		STM32_FUNCTION(8, "SDMMC2_CKIN SDMMC_BOOT2_CKIN"),
-		STM32_FUNCTION(9, "SDMMC1_CKIN SDMMC_BOOT1_CKIN"),
-		STM32_FUNCTION(10, "SDMMC2_D4 SDMMC_BOOT2_D4"),
-		STM32_FUNCTION(12, "SDMMC1_D4 SDMMC_BOOT1_D4"),
+		STM32_FUNCTION(8, "SDMMC2_CKIN"),
+		STM32_FUNCTION(9, "SDMMC1_CKIN"),
+		STM32_FUNCTION(10, "SDMMC2_D4"),
+		STM32_FUNCTION(12, "SDMMC1_D4"),
 		STM32_FUNCTION(13, "FMC_A20"),
 		STM32_FUNCTION(14, "DCMI_D4"),
 		STM32_FUNCTION(15, "LCD_B0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(69, "PE5"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE5"),
 		STM32_FUNCTION(1, "TRACED3"),
 		STM32_FUNCTION(3, "SAI1_CK2"),
-		STM32_FUNCTION(4, "DFSDM_CK3"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN3"),
 		STM32_FUNCTION(5, "TIM15_CH1"),
 		STM32_FUNCTION(6, "SPI4_MISO"),
 		STM32_FUNCTION(7, "SAI1_SCK_A"),
-		STM32_FUNCTION(8, "SDMMC2_D0DIR SDMMC_BOOT2_D0DIR"),
-		STM32_FUNCTION(9, "SDMMC1_D0DIR SDMMC_BOOT1_D0DIR"),
-		STM32_FUNCTION(10, "SDMMC2_D6 SDMMC_BOOT2_D6"),
-		STM32_FUNCTION(12, "SDMMC1_D6 SDMMC_BOOT1_D6"),
+		STM32_FUNCTION(8, "SDMMC2_D0DIR"),
+		STM32_FUNCTION(9, "SDMMC1_D0DIR"),
+		STM32_FUNCTION(10, "SDMMC2_D6"),
+		STM32_FUNCTION(12, "SDMMC1_D6"),
 		STM32_FUNCTION(13, "FMC_A21"),
 		STM32_FUNCTION(14, "DCMI_D6"),
 		STM32_FUNCTION(15, "LCD_G0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(70, "PE6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE6"),
 		STM32_FUNCTION(1, "TRACED2"),
 		STM32_FUNCTION(2, "TIM1_BKIN2"),
@@ -1030,7 +1093,7 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(6, "SPI4_MOSI"),
 		STM32_FUNCTION(7, "SAI1_SD_A"),
 		STM32_FUNCTION(8, "SDMMC2_D0"),
-		STM32_FUNCTION(9, "SDMMC1_D2 SDMMC_BOOT1_D2"),
+		STM32_FUNCTION(9, "SDMMC1_D2"),
 		STM32_FUNCTION(11, "SAI2_MCLK_B"),
 		STM32_FUNCTION(13, "FMC_A22"),
 		STM32_FUNCTION(14, "DCMI_D7"),
@@ -1038,119 +1101,132 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(71, "PE7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE7"),
 		STM32_FUNCTION(2, "TIM1_ETR"),
 		STM32_FUNCTION(3, "TIM3_ETR"),
-		STM32_FUNCTION(4, "DFSDM_DATA2"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN2"),
 		STM32_FUNCTION(8, "UART7_RX"),
-		STM32_FUNCTION(11, "QUADSPI_BK2_IO0 QUADSPI_BOOTBK2_IO0"),
-		STM32_FUNCTION(13, "FMC_D4"),
+		STM32_FUNCTION(11, "QUADSPI_BK2_IO0"),
+		STM32_FUNCTION(13, "FMC_D4 FMC_DA4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(72, "PE8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE8"),
 		STM32_FUNCTION(2, "TIM1_CH1N"),
-		STM32_FUNCTION(4, "DFSDM_CK2"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN2"),
 		STM32_FUNCTION(8, "UART7_TX"),
-		STM32_FUNCTION(11, "QUADSPI_BK2_IO1 QUADSPI_BOOTBK2_IO1"),
-		STM32_FUNCTION(13, "FMC_D5"),
+		STM32_FUNCTION(11, "QUADSPI_BK2_IO1"),
+		STM32_FUNCTION(13, "FMC_D5 FMC_DA5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(73, "PE9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE9"),
 		STM32_FUNCTION(2, "TIM1_CH1"),
-		STM32_FUNCTION(4, "DFSDM_CKOUT"),
-		STM32_FUNCTION(8, "UART7_RTS UART_BOOT7_RTS"),
-		STM32_FUNCTION(11, "QUADSPI_BK2_IO2 QUADSPI_BOOTBK2_IO2"),
-		STM32_FUNCTION(13, "FMC_D6"),
+		STM32_FUNCTION(4, "DFSDM1_CKOUT"),
+		STM32_FUNCTION(8, "UART7_RTS UART7_DE"),
+		STM32_FUNCTION(11, "QUADSPI_BK2_IO2"),
+		STM32_FUNCTION(13, "FMC_D6 FMC_DA6"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(74, "PE10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE10"),
 		STM32_FUNCTION(2, "TIM1_CH2N"),
-		STM32_FUNCTION(4, "DFSDM_DATA4"),
-		STM32_FUNCTION(8, "UART7_CTS UART_BOOT7_CTS"),
-		STM32_FUNCTION(11, "QUADSPI_BK2_IO3 QUADSPI_BOOTBK2_IO3"),
-		STM32_FUNCTION(13, "FMC_D7"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN4"),
+		STM32_FUNCTION(8, "UART7_CTS"),
+		STM32_FUNCTION(11, "QUADSPI_BK2_IO3"),
+		STM32_FUNCTION(13, "FMC_D7 FMC_DA7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(75, "PE11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE11"),
 		STM32_FUNCTION(2, "TIM1_CH2"),
-		STM32_FUNCTION(4, "DFSDM_CK4"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN4"),
 		STM32_FUNCTION(6, "SPI4_NSS"),
-		STM32_FUNCTION(8, "USART6_CK USART_BOOT6_CK"),
+		STM32_FUNCTION(8, "USART6_CK"),
 		STM32_FUNCTION(11, "SAI2_SD_B"),
-		STM32_FUNCTION(13, "FMC_D8"),
+		STM32_FUNCTION(13, "FMC_D8 FMC_DA8"),
+		STM32_FUNCTION(14, "DCMI_D4"),
 		STM32_FUNCTION(15, "LCD_G3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(76, "PE12"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE12"),
 		STM32_FUNCTION(2, "TIM1_CH3N"),
-		STM32_FUNCTION(4, "DFSDM_DATA5"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN5"),
 		STM32_FUNCTION(6, "SPI4_SCK"),
-		STM32_FUNCTION(9, "SDMMC1_D0DIR SDMMC_BOOT1_D0DIR"),
+		STM32_FUNCTION(9, "SDMMC1_D0DIR"),
 		STM32_FUNCTION(11, "SAI2_SCK_B"),
-		STM32_FUNCTION(13, "FMC_D9"),
+		STM32_FUNCTION(13, "FMC_D9 FMC_DA9"),
 		STM32_FUNCTION(15, "LCD_B4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(77, "PE13"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE13"),
 		STM32_FUNCTION(1, "HDP2"),
 		STM32_FUNCTION(2, "TIM1_CH3"),
-		STM32_FUNCTION(4, "DFSDM_CK5"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN5"),
 		STM32_FUNCTION(6, "SPI4_MISO"),
 		STM32_FUNCTION(11, "SAI2_FS_B"),
-		STM32_FUNCTION(13, "FMC_D10"),
+		STM32_FUNCTION(13, "FMC_D10 FMC_DA10"),
+		STM32_FUNCTION(14, "DCMI_D6"),
 		STM32_FUNCTION(15, "LCD_DE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(78, "PE14"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE14"),
 		STM32_FUNCTION(2, "TIM1_CH4"),
 		STM32_FUNCTION(6, "SPI4_MOSI"),
-		STM32_FUNCTION(9, "UART8_RTS UART_BOOT8_RTS"),
+		STM32_FUNCTION(9, "UART8_RTS UART8_DE"),
 		STM32_FUNCTION(11, "SAI2_MCLK_B"),
-		STM32_FUNCTION(12, "SDMMC1_D123DIR SDMMC_BOOT1_D123DIR"),
-		STM32_FUNCTION(13, "FMC_D11"),
+		STM32_FUNCTION(12, "SDMMC1_D123DIR"),
+		STM32_FUNCTION(13, "FMC_D11 FMC_DA11"),
 		STM32_FUNCTION(14, "LCD_G0"),
 		STM32_FUNCTION(15, "LCD_CLK"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(79, "PE15"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOE15"),
 		STM32_FUNCTION(1, "HDP3"),
 		STM32_FUNCTION(2, "TIM1_BKIN"),
 		STM32_FUNCTION(5, "TIM15_BKIN"),
-		STM32_FUNCTION(8, "USART2_CTS_NSS USART_BOOT2_CTS_NSS"),
-		STM32_FUNCTION(9, "UART8_CTS UART_BOOT8_CTS"),
-		STM32_FUNCTION(13, "FMC_D12"),
+		STM32_FUNCTION(8, "USART2_CTS USART2_NSS"),
+		STM32_FUNCTION(9, "UART8_CTS"),
+		STM32_FUNCTION(11, "FMC_NCE2"),
+		STM32_FUNCTION(13, "FMC_D12 FMC_DA12"),
 		STM32_FUNCTION(15, "LCD_R7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(80, "PF0"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF0"),
 		STM32_FUNCTION(5, "I2C2_SDA"),
 		STM32_FUNCTION(10, "SDMMC3_D0"),
@@ -1159,8 +1235,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(81, "PF1"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF1"),
 		STM32_FUNCTION(5, "I2C2_SCL"),
 		STM32_FUNCTION(10, "SDMMC3_CMD"),
@@ -1169,27 +1246,30 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(82, "PF2"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF2"),
 		STM32_FUNCTION(5, "I2C2_SMBA"),
-		STM32_FUNCTION(10, "SDMMC2_D0DIR SDMMC_BOOT2_D0DIR"),
+		STM32_FUNCTION(10, "SDMMC2_D0DIR"),
 		STM32_FUNCTION(11, "SDMMC3_D0DIR"),
-		STM32_FUNCTION(12, "SDMMC1_D0DIR SDMMC_BOOT1_D0DIR"),
+		STM32_FUNCTION(12, "SDMMC1_D0DIR"),
 		STM32_FUNCTION(13, "FMC_A2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(83, "PF3"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF3"),
-		STM32_FUNCTION(12, "ETH_GMII_TX_ER ETH_MII_TX_ER"),
+		STM32_FUNCTION(12, "ETH1_GMII_TX_ER ETH1_MII_TX_ER"),
 		STM32_FUNCTION(13, "FMC_A3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(84, "PF4"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF4"),
 		STM32_FUNCTION(8, "USART2_RX"),
 		STM32_FUNCTION(10, "SDMMC3_D1"),
@@ -1198,8 +1278,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(85, "PF5"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF5"),
 		STM32_FUNCTION(8, "USART2_TX"),
 		STM32_FUNCTION(10, "SDMMC3_D2"),
@@ -1207,71 +1288,77 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(86, "PF6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOF6"),
 		STM32_FUNCTION(2, "TIM16_CH1"),
 		STM32_FUNCTION(6, "SPI5_NSS"),
 		STM32_FUNCTION(7, "SAI1_SD_B"),
-		STM32_FUNCTION(8, "UART7_RX UART_BOOT7_RX"),
-		STM32_FUNCTION(10, "QUADSPI_BK1_IO3 QUADSPI_BOOTBK1_IO3"),
+		STM32_FUNCTION(8, "UART7_RX"),
+		STM32_FUNCTION(10, "QUADSPI_BK1_IO3"),
 		STM32_FUNCTION(13, "SAI4_SCK_B"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(87, "PF7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOF7"),
 		STM32_FUNCTION(2, "TIM17_CH1"),
 		STM32_FUNCTION(6, "SPI5_SCK"),
 		STM32_FUNCTION(7, "SAI1_MCLK_B"),
-		STM32_FUNCTION(8, "UART7_TX UART_BOOT7_TX"),
-		STM32_FUNCTION(10, "QUADSPI_BK1_IO2 QUADSPI_BOOTBK1_IO2"),
+		STM32_FUNCTION(8, "UART7_TX"),
+		STM32_FUNCTION(10, "QUADSPI_BK1_IO2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(88, "PF8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOF8"),
 		STM32_FUNCTION(1, "TRACED12"),
 		STM32_FUNCTION(2, "TIM16_CH1N"),
 		STM32_FUNCTION(6, "SPI5_MISO"),
 		STM32_FUNCTION(7, "SAI1_SCK_B"),
-		STM32_FUNCTION(8, "UART7_RTS UART_BOOT7_RTS"),
+		STM32_FUNCTION(8, "UART7_RTS UART7_DE"),
 		STM32_FUNCTION(10, "TIM13_CH1"),
-		STM32_FUNCTION(11, "QUADSPI_BK1_IO0 QUADSPI_BOOTBK1_IO0"),
+		STM32_FUNCTION(11, "QUADSPI_BK1_IO0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(89, "PF9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOF9"),
 		STM32_FUNCTION(1, "TRACED13"),
 		STM32_FUNCTION(2, "TIM17_CH1N"),
 		STM32_FUNCTION(6, "SPI5_MOSI"),
 		STM32_FUNCTION(7, "SAI1_FS_B"),
-		STM32_FUNCTION(8, "UART7_CTS UART_BOOT7_CTS"),
+		STM32_FUNCTION(8, "UART7_CTS"),
 		STM32_FUNCTION(10, "TIM14_CH1"),
-		STM32_FUNCTION(11, "QUADSPI_BK1_IO1 QUADSPI_BOOTBK1_IO1"),
+		STM32_FUNCTION(11, "QUADSPI_BK1_IO1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(90, "PF10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOF10"),
 		STM32_FUNCTION(2, "TIM16_BKIN"),
 		STM32_FUNCTION(3, "SAI1_D3"),
 		STM32_FUNCTION(4, "SAI4_D4"),
 		STM32_FUNCTION(7, "SAI1_D4"),
-		STM32_FUNCTION(10, "QUADSPI_CLK QUADSPI_BOOTCLK"),
+		STM32_FUNCTION(10, "QUADSPI_CLK"),
 		STM32_FUNCTION(13, "SAI4_D3"),
 		STM32_FUNCTION(14, "DCMI_D11"),
 		STM32_FUNCTION(15, "LCD_DE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(91, "PF11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOF11"),
 		STM32_FUNCTION(6, "SPI5_MOSI"),
 		STM32_FUNCTION(11, "SAI2_SD_B"),
@@ -1280,138 +1367,151 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(92, "PF12"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF12"),
 		STM32_FUNCTION(1, "TRACED4"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD4"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD4"),
 		STM32_FUNCTION(13, "FMC_A6"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(93, "PF13"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF13"),
 		STM32_FUNCTION(1, "TRACED5"),
-		STM32_FUNCTION(4, "DFSDM_DATA6"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN6"),
 		STM32_FUNCTION(5, "I2C4_SMBA"),
 		STM32_FUNCTION(6, "I2C1_SMBA"),
-		STM32_FUNCTION(7, "DFSDM_DATA3"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD5"),
+		STM32_FUNCTION(7, "DFSDM1_DATIN3"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD5"),
 		STM32_FUNCTION(13, "FMC_A7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(94, "PF14"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF14"),
 		STM32_FUNCTION(1, "TRACED6"),
-		STM32_FUNCTION(4, "DFSDM_CK6"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN6"),
 		STM32_FUNCTION(5, "I2C4_SCL"),
 		STM32_FUNCTION(6, "I2C1_SCL"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD6"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD6"),
 		STM32_FUNCTION(13, "FMC_A8"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(95, "PF15"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOF15"),
 		STM32_FUNCTION(1, "TRACED7"),
 		STM32_FUNCTION(5, "I2C4_SDA"),
 		STM32_FUNCTION(6, "I2C1_SDA"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD7"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD7"),
 		STM32_FUNCTION(13, "FMC_A9"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(96, "PG0"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOG0"),
 		STM32_FUNCTION(1, "TRACED0"),
-		STM32_FUNCTION(4, "DFSDM_DATA0"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD4"),
+		STM32_FUNCTION(4, "DFSDM1_DATIN0"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD4"),
 		STM32_FUNCTION(13, "FMC_A10"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(97, "PG1"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOG1"),
 		STM32_FUNCTION(1, "TRACED1"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD5"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD5"),
 		STM32_FUNCTION(13, "FMC_A11"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(98, "PG2"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOG2"),
 		STM32_FUNCTION(1, "TRACED2"),
 		STM32_FUNCTION(2, "MCO2"),
 		STM32_FUNCTION(4, "TIM8_BKIN"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD6"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD6"),
 		STM32_FUNCTION(13, "FMC_A12"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(99, "PG3"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOG3"),
 		STM32_FUNCTION(1, "TRACED3"),
 		STM32_FUNCTION(4, "TIM8_BKIN2"),
-		STM32_FUNCTION(5, "DFSDM_CK1"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD7"),
+		STM32_FUNCTION(5, "DFSDM1_CKIN1"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD7"),
 		STM32_FUNCTION(13, "FMC_A13"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(100, "PG4"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOG4"),
 		STM32_FUNCTION(2, "TIM1_BKIN2"),
-		STM32_FUNCTION(12, "ETH_GMII_GTX_CLK ETH_RGMII_GTX_CLK"),
+		STM32_FUNCTION(12, "ETH1_GMII_GTX_CLK ETH1_RGMII_GTX_CLK"),
 		STM32_FUNCTION(13, "FMC_A14"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(101, "PG5"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOG5"),
 		STM32_FUNCTION(2, "TIM1_ETR"),
-		STM32_FUNCTION(12, "ETH_GMII_CLK125 ETH_RGMII_CLK125"),
+		STM32_FUNCTION(12, "ETH1_GMII_CLK125 ETH1_RGMII_CLK125"),
 		STM32_FUNCTION(13, "FMC_A15"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(102, "PG6"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG6"),
 		STM32_FUNCTION(1, "TRACED14"),
 		STM32_FUNCTION(2, "TIM17_BKIN"),
-		STM32_FUNCTION(11, "SDMMC2_CMD SDMMC_BOOT2_CMD"),
+		STM32_FUNCTION(11, "SDMMC2_CMD"),
 		STM32_FUNCTION(14, "DCMI_D12"),
 		STM32_FUNCTION(15, "LCD_R7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(103, "PG7"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG7"),
 		STM32_FUNCTION(1, "TRACED5"),
 		STM32_FUNCTION(7, "SAI1_MCLK_A"),
-		STM32_FUNCTION(8, "USART6_CK USART_BOOT6_CK"),
-		STM32_FUNCTION(9, "UART8_RTS UART_BOOT8_RTS"),
+		STM32_FUNCTION(8, "USART6_CK"),
+		STM32_FUNCTION(9, "UART8_RTS UART8_DE"),
 		STM32_FUNCTION(10, "QUADSPI_CLK"),
-		STM32_FUNCTION(12, "QUADSPI_BK2_IO3 QUADSPI_BOOTBK2_IO3"),
+		STM32_FUNCTION(12, "QUADSPI_BK2_IO3"),
 		STM32_FUNCTION(13, "FMC_INT"),
 		STM32_FUNCTION(14, "DCMI_D13"),
 		STM32_FUNCTION(15, "LCD_CLK"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(104, "PG8"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG8"),
 		STM32_FUNCTION(1, "TRACED15"),
 		STM32_FUNCTION(2, "TIM2_CH1 TIM2_ETR"),
@@ -1419,73 +1519,79 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(4, "TIM8_ETR"),
 		STM32_FUNCTION(6, "SPI6_NSS"),
 		STM32_FUNCTION(7, "SAI4_D2"),
-		STM32_FUNCTION(8, "USART6_RTS USART_BOOT6_RTS"),
-		STM32_FUNCTION(9, "USART3_RTS"),
-		STM32_FUNCTION(10, "SPDIF_IN2"),
+		STM32_FUNCTION(8, "USART6_RTS USART6_DE"),
+		STM32_FUNCTION(9, "USART3_RTS USART3_DE"),
+		STM32_FUNCTION(10, "SPDIFRX_IN2"),
 		STM32_FUNCTION(11, "SAI4_FS_A"),
-		STM32_FUNCTION(12, "ETH_PPS_OUT"),
+		STM32_FUNCTION(12, "ETH1_PPS_OUT"),
 		STM32_FUNCTION(15, "LCD_G7"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(105, "PG9"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG9"),
 		STM32_FUNCTION(1, "DBTRGO"),
 		STM32_FUNCTION(8, "USART6_RX"),
-		STM32_FUNCTION(9, "SPDIF_IN3"),
-		STM32_FUNCTION(10, "QUADSPI_BK2_IO2 QUADSPI_BOOTBK2_IO2"),
+		STM32_FUNCTION(9, "SPDIFRX_IN3"),
+		STM32_FUNCTION(10, "QUADSPI_BK2_IO2"),
 		STM32_FUNCTION(11, "SAI2_FS_B"),
-		STM32_FUNCTION(13, "FMC_NE2 FMC_NCE"),
+		STM32_FUNCTION(13, "FMC_NCE FMC_NE2"),
 		STM32_FUNCTION(14, "DCMI_VSYNC"),
+		STM32_FUNCTION(15, "LCD_R1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(106, "PG10"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG10"),
 		STM32_FUNCTION(1, "TRACED10"),
-		STM32_FUNCTION(9, "UART8_CTS UART_BOOT8_CTS"),
+		STM32_FUNCTION(9, "UART8_CTS"),
 		STM32_FUNCTION(10, "LCD_G3"),
 		STM32_FUNCTION(11, "SAI2_SD_B"),
-		STM32_FUNCTION(12, "QUADSPI_BK2_IO2 QUADSPI_BOOTBK2_IO2"),
+		STM32_FUNCTION(12, "QUADSPI_BK2_IO2"),
 		STM32_FUNCTION(13, "FMC_NE3"),
 		STM32_FUNCTION(14, "DCMI_D2"),
 		STM32_FUNCTION(15, "LCD_B2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(107, "PG11"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG11"),
 		STM32_FUNCTION(1, "TRACED11"),
 		STM32_FUNCTION(5, "USART1_TX"),
-		STM32_FUNCTION(7, "UART4_TX UART_BOOT4_TX"),
-		STM32_FUNCTION(9, "SPDIF_IN0"),
-		STM32_FUNCTION(12, "ETH_GMII_TX_EN ETH_MII_TX_EN ETH_RGMII_TX_CTL ETH_RMII_TX_EN"),
+		STM32_FUNCTION(7, "UART4_TX"),
+		STM32_FUNCTION(9, "SPDIFRX_IN0"),
+		STM32_FUNCTION(12, "ETH1_GMII_TX_EN ETH1_MII_TX_EN ETH1_RGMII_TX_CTL ETH1_RMII_TX_EN"),
 		STM32_FUNCTION(14, "DCMI_D3"),
 		STM32_FUNCTION(15, "LCD_B3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(108, "PG12"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG12"),
 		STM32_FUNCTION(2, "LPTIM1_IN1"),
 		STM32_FUNCTION(6, "SPI6_MISO"),
 		STM32_FUNCTION(7, "SAI4_CK2"),
-		STM32_FUNCTION(8, "USART6_RTS USART_BOOT6_RTS"),
-		STM32_FUNCTION(9, "SPDIF_IN1"),
+		STM32_FUNCTION(8, "USART6_RTS USART6_DE"),
+		STM32_FUNCTION(9, "SPDIFRX_IN1"),
 		STM32_FUNCTION(10, "LCD_B4"),
 		STM32_FUNCTION(11, "SAI4_SCK_A"),
-		STM32_FUNCTION(12, "ETH_PHY_INTN"),
+		STM32_FUNCTION(12, "ETH1_PHY_INTN"),
 		STM32_FUNCTION(13, "FMC_NE4"),
 		STM32_FUNCTION(15, "LCD_B1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(109, "PG13"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG13"),
 		STM32_FUNCTION(1, "TRACED0"),
 		STM32_FUNCTION(2, "LPTIM1_OUT"),
@@ -1493,79 +1599,86 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(5, "SAI4_CK1"),
 		STM32_FUNCTION(6, "SPI6_SCK"),
 		STM32_FUNCTION(7, "SAI1_SCK_A"),
-		STM32_FUNCTION(8, "USART6_CTS_NSS USART_BOOT6_CTS_NSS"),
+		STM32_FUNCTION(8, "USART6_CTS USART6_NSS"),
 		STM32_FUNCTION(11, "SAI4_MCLK_A"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD0 ETH_MII_TXD0 ETH_RGMII_TXD0 ETH_RMII_TXD0"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD0 ETH1_MII_TXD0 ETH1_RGMII_TXD0 ETH1_RMII_TXD0"),
 		STM32_FUNCTION(13, "FMC_A24"),
 		STM32_FUNCTION(15, "LCD_R0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(110, "PG14"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG14"),
 		STM32_FUNCTION(1, "TRACED1"),
 		STM32_FUNCTION(2, "LPTIM1_ETR"),
 		STM32_FUNCTION(6, "SPI6_MOSI"),
 		STM32_FUNCTION(7, "SAI4_D1"),
 		STM32_FUNCTION(8, "USART6_TX"),
-		STM32_FUNCTION(10, "QUADSPI_BK2_IO3 QUADSPI_BOOTBK2_IO3"),
+		STM32_FUNCTION(10, "QUADSPI_BK2_IO3"),
 		STM32_FUNCTION(11, "SAI4_SD_A"),
-		STM32_FUNCTION(12, "ETH_GMII_TXD1 ETH_MII_TXD1 ETH_RGMII_TXD1 ETH_RMII_TXD1"),
+		STM32_FUNCTION(12, "ETH1_GMII_TXD1 ETH1_MII_TXD1 ETH1_RGMII_TXD1 ETH1_RMII_TXD1"),
 		STM32_FUNCTION(13, "FMC_A25"),
 		STM32_FUNCTION(15, "LCD_B0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(111, "PG15"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOG15"),
 		STM32_FUNCTION(1, "TRACED7"),
 		STM32_FUNCTION(3, "SAI1_D2"),
 		STM32_FUNCTION(5, "I2C2_SDA"),
 		STM32_FUNCTION(7, "SAI1_FS_A"),
-		STM32_FUNCTION(8, "USART6_CTS_NSS USART_BOOT6_CTS_NSS"),
+		STM32_FUNCTION(8, "USART6_CTS USART6_NSS"),
 		STM32_FUNCTION(11, "SDMMC3_CK"),
 		STM32_FUNCTION(14, "DCMI_D13"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(112, "PH0"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOH0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(113, "PH1"),
+		STM32MP157CAA | STM32MP157CAC | STM32MP157CAB | STM32MP157CAD,
 		STM32_FUNCTION(0, "GPIOH1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(114, "PH2"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH2"),
 		STM32_FUNCTION(2, "LPTIM1_IN2"),
-		STM32_FUNCTION(10, "QUADSPI_BK2_IO0 QUADSPI_BOOTBK2_IO0"),
+		STM32_FUNCTION(10, "QUADSPI_BK2_IO0"),
 		STM32_FUNCTION(11, "SAI2_SCK_B"),
-		STM32_FUNCTION(12, "ETH_GMII_CRS ETH_MII_CRS"),
+		STM32_FUNCTION(12, "ETH1_GMII_CRS ETH1_MII_CRS"),
 		STM32_FUNCTION(15, "LCD_R0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(115, "PH3"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH3"),
-		STM32_FUNCTION(4, "DFSDM_CK4"),
-		STM32_FUNCTION(10, "QUADSPI_BK2_IO1 QUADSPI_BOOTBK2_IO1"),
+		STM32_FUNCTION(4, "DFSDM1_CKIN4"),
+		STM32_FUNCTION(10, "QUADSPI_BK2_IO1"),
 		STM32_FUNCTION(11, "SAI2_MCLK_B"),
-		STM32_FUNCTION(12, "ETH_GMII_COL ETH_MII_COL"),
+		STM32_FUNCTION(12, "ETH1_GMII_COL ETH1_MII_COL"),
 		STM32_FUNCTION(15, "LCD_R1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(116, "PH4"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH4"),
 		STM32_FUNCTION(5, "I2C2_SCL"),
 		STM32_FUNCTION(10, "LCD_G5"),
@@ -1573,8 +1686,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(117, "PH5"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH5"),
 		STM32_FUNCTION(5, "I2C2_SDA"),
 		STM32_FUNCTION(6, "SPI5_NSS"),
@@ -1582,31 +1696,34 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(118, "PH6"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH6"),
 		STM32_FUNCTION(3, "TIM12_CH1"),
 		STM32_FUNCTION(5, "I2C2_SMBA"),
 		STM32_FUNCTION(6, "SPI5_SCK"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD2 ETH_MII_RXD2 ETH_RGMII_RXD2"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD2 ETH1_MII_RXD2 ETH1_RGMII_RXD2"),
 		STM32_FUNCTION(13, "MDIOS_MDIO"),
 		STM32_FUNCTION(14, "DCMI_D8"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(119, "PH7"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH7"),
 		STM32_FUNCTION(5, "I2C3_SCL"),
 		STM32_FUNCTION(6, "SPI5_MISO"),
-		STM32_FUNCTION(12, "ETH_GMII_RXD3 ETH_MII_RXD3 ETH_RGMII_RXD3"),
+		STM32_FUNCTION(12, "ETH1_GMII_RXD3 ETH1_MII_RXD3 ETH1_RGMII_RXD3"),
 		STM32_FUNCTION(13, "MDIOS_MDC"),
 		STM32_FUNCTION(14, "DCMI_D9"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(120, "PH8"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH8"),
 		STM32_FUNCTION(3, "TIM5_ETR"),
 		STM32_FUNCTION(5, "I2C3_SDA"),
@@ -1615,8 +1732,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(121, "PH9"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH9"),
 		STM32_FUNCTION(3, "TIM12_CH2"),
 		STM32_FUNCTION(5, "I2C3_SMBA"),
@@ -1625,8 +1743,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(122, "PH10"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH10"),
 		STM32_FUNCTION(3, "TIM5_CH1"),
 		STM32_FUNCTION(5, "I2C4_SMBA"),
@@ -1636,8 +1755,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(123, "PH11"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH11"),
 		STM32_FUNCTION(3, "TIM5_CH2"),
 		STM32_FUNCTION(5, "I2C4_SCL"),
@@ -1647,8 +1767,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(124, "PH12"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH12"),
 		STM32_FUNCTION(1, "HDP2"),
 		STM32_FUNCTION(3, "TIM5_CH3"),
@@ -1659,50 +1780,53 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(125, "PH13"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH13"),
 		STM32_FUNCTION(4, "TIM8_CH1N"),
 		STM32_FUNCTION(9, "UART4_TX"),
-		STM32_FUNCTION(10, "CAN1_TX"),
+		STM32_FUNCTION(10, "FDCAN1_TX"),
 		STM32_FUNCTION(15, "LCD_G2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(126, "PH14"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH14"),
 		STM32_FUNCTION(4, "TIM8_CH2N"),
 		STM32_FUNCTION(9, "UART4_RX"),
-		STM32_FUNCTION(10, "CAN1_RX"),
+		STM32_FUNCTION(10, "FDCAN1_RX"),
 		STM32_FUNCTION(14, "DCMI_D4"),
 		STM32_FUNCTION(15, "LCD_G3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(127, "PH15"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOH15"),
 		STM32_FUNCTION(4, "TIM8_CH3N"),
-		STM32_FUNCTION(10, "CAN1_TXFD"),
 		STM32_FUNCTION(14, "DCMI_D11"),
 		STM32_FUNCTION(15, "LCD_G4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(128, "PI0"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI0"),
 		STM32_FUNCTION(3, "TIM5_CH4"),
 		STM32_FUNCTION(6, "SPI2_NSS I2S2_WS"),
-		STM32_FUNCTION(10, "CAN1_RXFD"),
 		STM32_FUNCTION(14, "DCMI_D13"),
 		STM32_FUNCTION(15, "LCD_G5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(129, "PI1"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI1"),
 		STM32_FUNCTION(4, "TIM8_BKIN2"),
 		STM32_FUNCTION(6, "SPI2_SCK I2S2_CK"),
@@ -1711,8 +1835,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(130, "PI2"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI2"),
 		STM32_FUNCTION(4, "TIM8_CH4"),
 		STM32_FUNCTION(6, "SPI2_MISO I2S2_SDI"),
@@ -1721,8 +1846,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(131, "PI3"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI3"),
 		STM32_FUNCTION(4, "TIM8_ETR"),
 		STM32_FUNCTION(6, "SPI2_MOSI I2S2_SDO"),
@@ -1730,8 +1856,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(132, "PI4"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI4"),
 		STM32_FUNCTION(4, "TIM8_BKIN"),
 		STM32_FUNCTION(11, "SAI2_MCLK_A"),
@@ -1740,8 +1867,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(133, "PI5"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI5"),
 		STM32_FUNCTION(4, "TIM8_CH1"),
 		STM32_FUNCTION(11, "SAI2_SCK_A"),
@@ -1750,8 +1878,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(134, "PI6"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI6"),
 		STM32_FUNCTION(4, "TIM8_CH2"),
 		STM32_FUNCTION(11, "SAI2_SD_A"),
@@ -1760,8 +1889,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(135, "PI7"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI7"),
 		STM32_FUNCTION(4, "TIM8_CH3"),
 		STM32_FUNCTION(11, "SAI2_FS_A"),
@@ -1770,35 +1900,38 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(136, "PI8"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI8"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(137, "PI9"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI9"),
 		STM32_FUNCTION(1, "HDP1"),
 		STM32_FUNCTION(9, "UART4_RX"),
-		STM32_FUNCTION(10, "CAN1_RX"),
+		STM32_FUNCTION(10, "FDCAN1_RX"),
 		STM32_FUNCTION(15, "LCD_VSYNC"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(138, "PI10"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI10"),
 		STM32_FUNCTION(1, "HDP0"),
-		STM32_FUNCTION(9, "USART3_CTS_NSS USART_BOOT3_CTS_NSS"),
-		STM32_FUNCTION(10, "CAN1_RXFD"),
-		STM32_FUNCTION(12, "ETH_GMII_RX_ER ETH_MII_RX_ER"),
+		STM32_FUNCTION(9, "USART3_CTS USART3_NSS"),
+		STM32_FUNCTION(12, "ETH1_GMII_RX_ER ETH1_MII_RX_ER"),
 		STM32_FUNCTION(15, "LCD_HSYNC"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(139, "PI11"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOI11"),
 		STM32_FUNCTION(1, "MCO1"),
 		STM32_FUNCTION(6, "I2S_CKIN"),
@@ -1806,8 +1939,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(140, "PI12"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOI12"),
 		STM32_FUNCTION(1, "TRACED0"),
 		STM32_FUNCTION(3, "HDP0"),
@@ -1815,8 +1949,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(141, "PI13"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOI13"),
 		STM32_FUNCTION(1, "TRACED1"),
 		STM32_FUNCTION(3, "HDP1"),
@@ -1824,24 +1959,27 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(142, "PI14"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOI14"),
 		STM32_FUNCTION(1, "TRACECLK"),
 		STM32_FUNCTION(15, "LCD_CLK"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(143, "PI15"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOI15"),
 		STM32_FUNCTION(10, "LCD_G2"),
 		STM32_FUNCTION(15, "LCD_R0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(144, "PJ0"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ0"),
 		STM32_FUNCTION(1, "TRACED8"),
 		STM32_FUNCTION(10, "LCD_R7"),
@@ -1849,16 +1987,18 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(145, "PJ1"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ1"),
 		STM32_FUNCTION(1, "TRACED9"),
 		STM32_FUNCTION(15, "LCD_R2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(146, "PJ2"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ2"),
 		STM32_FUNCTION(1, "TRACED10"),
 		STM32_FUNCTION(14, "DSI_TE"),
@@ -1866,24 +2006,27 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(147, "PJ3"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ3"),
 		STM32_FUNCTION(1, "TRACED11"),
 		STM32_FUNCTION(15, "LCD_R4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(148, "PJ4"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ4"),
 		STM32_FUNCTION(1, "TRACED12"),
 		STM32_FUNCTION(15, "LCD_R5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(149, "PJ5"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ5"),
 		STM32_FUNCTION(1, "TRACED2"),
 		STM32_FUNCTION(3, "HDP2"),
@@ -1891,8 +2034,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(150, "PJ6"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ6"),
 		STM32_FUNCTION(1, "TRACED3"),
 		STM32_FUNCTION(3, "HDP3"),
@@ -1901,8 +2045,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(151, "PJ7"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ7"),
 		STM32_FUNCTION(1, "TRACED13"),
 		STM32_FUNCTION(4, "TIM8_CH2N"),
@@ -1910,8 +2055,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(152, "PJ8"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ8"),
 		STM32_FUNCTION(1, "TRACED14"),
 		STM32_FUNCTION(2, "TIM1_CH3N"),
@@ -1921,8 +2067,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(153, "PJ9"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ9"),
 		STM32_FUNCTION(1, "TRACED15"),
 		STM32_FUNCTION(2, "TIM1_CH3"),
@@ -1932,8 +2079,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(154, "PJ10"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ10"),
 		STM32_FUNCTION(2, "TIM1_CH2N"),
 		STM32_FUNCTION(4, "TIM8_CH2"),
@@ -1942,8 +2090,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(155, "PJ11"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ11"),
 		STM32_FUNCTION(2, "TIM1_CH2"),
 		STM32_FUNCTION(4, "TIM8_CH2N"),
@@ -1952,38 +2101,43 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(156, "PJ12"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ12"),
 		STM32_FUNCTION(10, "LCD_G3"),
 		STM32_FUNCTION(15, "LCD_B0"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(157, "PJ13"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ13"),
 		STM32_FUNCTION(10, "LCD_G4"),
 		STM32_FUNCTION(15, "LCD_B1"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(158, "PJ14"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ14"),
 		STM32_FUNCTION(15, "LCD_B2"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(159, "PJ15"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOJ15"),
 		STM32_FUNCTION(15, "LCD_B3"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(160, "PK0"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK0"),
 		STM32_FUNCTION(2, "TIM1_CH1N"),
 		STM32_FUNCTION(4, "TIM8_CH3"),
@@ -1992,8 +2146,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(161, "PK1"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK1"),
 		STM32_FUNCTION(1, "TRACED4"),
 		STM32_FUNCTION(2, "TIM1_CH1"),
@@ -2004,8 +2159,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(162, "PK2"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK2"),
 		STM32_FUNCTION(1, "TRACED5"),
 		STM32_FUNCTION(2, "TIM1_BKIN"),
@@ -2015,22 +2171,25 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(163, "PK3"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK3"),
 		STM32_FUNCTION(15, "LCD_B4"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(164, "PK4"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK4"),
 		STM32_FUNCTION(15, "LCD_B5"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(165, "PK5"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK5"),
 		STM32_FUNCTION(1, "TRACED6"),
 		STM32_FUNCTION(3, "HDP6"),
@@ -2038,8 +2197,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(166, "PK6"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK6"),
 		STM32_FUNCTION(1, "TRACED7"),
 		STM32_FUNCTION(3, "HDP7"),
@@ -2047,8 +2207,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(167, "PK7"),
+		STM32MP157CAA,
 		STM32_FUNCTION(0, "GPIOK7"),
 		STM32_FUNCTION(15, "LCD_DE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
@@ -2057,8 +2218,9 @@ static const struct stm32_desc_pin stm32mp157_pins[] = {
 };
 
 static const struct stm32_desc_pin stm32mp157_z_pins[] = {
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(400, "PZ0"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ0"),
 		STM32_FUNCTION(3, "I2C6_SCL"),
 		STM32_FUNCTION(4, "I2C2_SCL"),
@@ -2068,8 +2230,9 @@ static const struct stm32_desc_pin stm32mp157_z_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(401, "PZ1"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ1"),
 		STM32_FUNCTION(3, "I2C6_SDA"),
 		STM32_FUNCTION(4, "I2C2_SDA"),
@@ -2081,8 +2244,9 @@ static const struct stm32_desc_pin stm32mp157_z_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(402, "PZ2"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ2"),
 		STM32_FUNCTION(3, "I2C6_SCL"),
 		STM32_FUNCTION(4, "I2C2_SCL"),
@@ -2094,21 +2258,23 @@ static const struct stm32_desc_pin stm32mp157_z_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(403, "PZ3"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ3"),
 		STM32_FUNCTION(3, "I2C6_SDA"),
 		STM32_FUNCTION(4, "I2C2_SDA"),
 		STM32_FUNCTION(5, "I2C5_SDA"),
 		STM32_FUNCTION(6, "SPI1_NSS I2S1_WS"),
 		STM32_FUNCTION(7, "I2C4_SDA"),
-		STM32_FUNCTION(8, "USART1_CTS_NSS"),
+		STM32_FUNCTION(8, "USART1_CTS USART1_NSS"),
 		STM32_FUNCTION(9, "SPI6_NSS"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(404, "PZ4"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ4"),
 		STM32_FUNCTION(3, "I2C6_SCL"),
 		STM32_FUNCTION(4, "I2C2_SCL"),
@@ -2117,19 +2283,21 @@ static const struct stm32_desc_pin stm32mp157_z_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(405, "PZ5"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ5"),
 		STM32_FUNCTION(3, "I2C6_SDA"),
 		STM32_FUNCTION(4, "I2C2_SDA"),
 		STM32_FUNCTION(5, "I2C5_SDA"),
 		STM32_FUNCTION(7, "I2C4_SDA"),
-		STM32_FUNCTION(8, "USART1_RTS"),
+		STM32_FUNCTION(8, "USART1_RTS USART1_DE"),
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(406, "PZ6"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ6"),
 		STM32_FUNCTION(3, "I2C6_SCL"),
 		STM32_FUNCTION(4, "I2C2_SCL"),
@@ -2140,8 +2308,9 @@ static const struct stm32_desc_pin stm32mp157_z_pins[] = {
 		STM32_FUNCTION(16, "EVENTOUT"),
 		STM32_FUNCTION(17, "ANALOG")
 	),
-	STM32_PIN(
+	STM32_PIN_PKG(
 		PINCTRL_PIN(407, "PZ7"),
+		STM32MP157CAA | STM32MP157CAC,
 		STM32_FUNCTION(0, "GPIOZ7"),
 		STM32_FUNCTION(3, "I2C6_SDA"),
 		STM32_FUNCTION(4, "I2C2_SDA"),
@@ -2159,6 +2328,7 @@ static struct stm32_pinctrl_match_data stm32mp157_match_data = {
 static struct stm32_pinctrl_match_data stm32mp157_z_match_data = {
 	.pins = stm32mp157_z_pins,
 	.npins = ARRAY_SIZE(stm32mp157_z_pins),
+	.pin_base_shift = STM32MP157_Z_BASE_SHIFT,
 };
 
 static const struct of_device_id stm32mp157_pctrl_match[] = {
@@ -2173,11 +2343,16 @@ static const struct of_device_id stm32mp157_pctrl_match[] = {
 	{ }
 };
 
+static const struct dev_pm_ops stm32_pinctrl_dev_pm_ops = {
+	 SET_LATE_SYSTEM_SLEEP_PM_OPS(NULL, stm32_pinctrl_resume)
+};
+
 static struct platform_driver stm32mp157_pinctrl_driver = {
 	.probe = stm32_pctl_probe,
 	.driver = {
 		.name = "stm32mp157-pinctrl",
 		.of_match_table = stm32mp157_pctrl_match,
+		.pm = &stm32_pinctrl_dev_pm_ops,
 	},
 };
 
diff --git a/drivers/pwm/pwm-stm32-lp.c b/drivers/pwm/pwm-stm32-lp.c
index 0059b24c..322df1f 100644
--- a/drivers/pwm/pwm-stm32-lp.c
+++ b/drivers/pwm/pwm-stm32-lp.c
@@ -13,6 +13,7 @@
 #include <linux/mfd/stm32-lptimer.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pwm.h>
 
@@ -20,6 +21,8 @@ struct stm32_pwm_lp {
 	struct pwm_chip chip;
 	struct clk *clk;
 	struct regmap *regmap;
+	struct pwm_state suspend;
+	bool suspended;
 };
 
 static inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)
@@ -58,6 +61,12 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 	/* Calculate the period and prescaler value */
 	div = (unsigned long long)clk_get_rate(priv->clk) * state->period;
 	do_div(div, NSEC_PER_SEC);
+	if (!div) {
+		/* Fall here in case source clock < period */
+		dev_err(priv->chip.dev, "Can't reach expected period\n");
+		return -EINVAL;
+	}
+
 	prd = div;
 	while (div > STM32_LPTIM_MAX_ARR) {
 		presc++;
@@ -223,6 +232,40 @@ static int stm32_pwm_lp_remove(struct platform_device *pdev)
 	return pwmchip_remove(&priv->chip);
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int stm32_pwm_lp_suspend(struct device *dev)
+{
+	struct stm32_pwm_lp *priv = dev_get_drvdata(dev);
+
+	pwm_get_state(&priv->chip.pwms[0], &priv->suspend);
+	priv->suspended = priv->suspend.enabled;
+
+	/* safe to call pwm_disable() for already disabled pwm */
+	pwm_disable(&priv->chip.pwms[0]);
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int stm32_pwm_lp_resume(struct device *dev)
+{
+	struct stm32_pwm_lp *priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret)
+		return ret;
+
+	/* Only restore suspended pwm, not to disrupt other MFD child */
+	if (!priv->suspended)
+		return 0;
+
+	return pwm_apply_state(&priv->chip.pwms[0], &priv->suspend);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(stm32_pwm_lp_pm_ops, stm32_pwm_lp_suspend,
+			 stm32_pwm_lp_resume);
+
 static const struct of_device_id stm32_pwm_lp_of_match[] = {
 	{ .compatible = "st,stm32-pwm-lp", },
 	{},
@@ -235,6 +278,7 @@ static struct platform_driver stm32_pwm_lp_driver = {
 	.driver	= {
 		.name = "stm32-pwm-lp",
 		.of_match_table = of_match_ptr(stm32_pwm_lp_of_match),
+		.pm = &stm32_pwm_lp_pm_ops,
 	},
 };
 module_platform_driver(stm32_pwm_lp_driver);
diff --git a/drivers/pwm/pwm-stm32.c b/drivers/pwm/pwm-stm32.c
index 4f84255..5a6c765 100644
--- a/drivers/pwm/pwm-stm32.c
+++ b/drivers/pwm/pwm-stm32.c
@@ -12,6 +12,7 @@
 #include <linux/mfd/stm32-timers.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pwm.h>
 
@@ -19,6 +20,12 @@
 #define CCMR_CHANNEL_MASK  0xFF
 #define MAX_BREAKINPUT 2
 
+struct stm32_breakinput {
+	u32 index;
+	u32 level;
+	u32 filter;
+};
+
 struct stm32_pwm {
 	struct pwm_chip chip;
 	struct mutex lock; /* protect pwm config/enable */
@@ -26,15 +33,13 @@ struct stm32_pwm {
 	struct regmap *regmap;
 	u32 max_arr;
 	bool have_complementary_output;
+	struct stm32_breakinput breakinput[MAX_BREAKINPUT];
+	unsigned int nbreakinput;
+	struct pwm_state suspend[4];
+	bool suspended[4];
 	u32 capture[4] ____cacheline_aligned; /* DMA'able buffer */
 };
 
-struct stm32_breakinput {
-	u32 index;
-	u32 level;
-	u32 filter;
-};
-
 static inline struct stm32_pwm *to_stm32_pwm_dev(struct pwm_chip *chip)
 {
 	return container_of(chip, struct stm32_pwm, chip);
@@ -374,9 +379,7 @@ static int stm32_pwm_config(struct stm32_pwm *priv, int ch,
 	else
 		regmap_update_bits(priv->regmap, TIM_CCMR2, mask, ccmr);
 
-	regmap_update_bits(priv->regmap, TIM_BDTR,
-			   TIM_BDTR_MOE | TIM_BDTR_AOE,
-			   TIM_BDTR_MOE | TIM_BDTR_AOE);
+	regmap_update_bits(priv->regmap, TIM_BDTR, TIM_BDTR_MOE, TIM_BDTR_MOE);
 
 	return 0;
 }
@@ -512,15 +515,27 @@ static int stm32_pwm_set_breakinput(struct stm32_pwm *priv,
 	return (bdtr & bke) ? 0 : -EINVAL;
 }
 
-static int stm32_pwm_apply_breakinputs(struct stm32_pwm *priv,
+static int stm32_pwm_apply_breakinputs(struct stm32_pwm *priv)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < priv->nbreakinput && !ret; i++) {
+		ret = stm32_pwm_set_breakinput(priv,
+					       priv->breakinput[i].index,
+					       priv->breakinput[i].level,
+					       priv->breakinput[i].filter);
+	}
+
+	return ret;
+}
+
+static int stm32_pwm_probe_breakinputs(struct stm32_pwm *priv,
 				       struct device_node *np)
 {
-	struct stm32_breakinput breakinput[MAX_BREAKINPUT];
-	int nb, ret, i, array_size;
+	int nb, ret, array_size;
 
 	nb = of_property_count_elems_of_size(np, "st,breakinput",
 					     sizeof(struct stm32_breakinput));
-
 	/*
 	 * Because "st,breakinput" parameter is optional do not make probe
 	 * failed if it doesn't exist.
@@ -531,20 +546,14 @@ static int stm32_pwm_apply_breakinputs(struct stm32_pwm *priv,
 	if (nb > MAX_BREAKINPUT)
 		return -EINVAL;
 
+	priv->nbreakinput = nb;
 	array_size = nb * sizeof(struct stm32_breakinput) / sizeof(u32);
 	ret = of_property_read_u32_array(np, "st,breakinput",
-					 (u32 *)breakinput, array_size);
+					 (u32 *)priv->breakinput, array_size);
 	if (ret)
 		return ret;
 
-	for (i = 0; i < nb && !ret; i++) {
-		ret = stm32_pwm_set_breakinput(priv,
-					       breakinput[i].index,
-					       breakinput[i].level,
-					       breakinput[i].filter);
-	}
-
-	return ret;
+	return stm32_pwm_apply_breakinputs(priv);
 }
 
 static void stm32_pwm_detect_complementary(struct stm32_pwm *priv)
@@ -612,7 +621,7 @@ static int stm32_pwm_probe(struct platform_device *pdev)
 	if (!priv->regmap || !priv->clk)
 		return -EINVAL;
 
-	ret = stm32_pwm_apply_breakinputs(priv, np);
+	ret = stm32_pwm_probe_breakinputs(priv, np);
 	if (ret)
 		return ret;
 
@@ -645,6 +654,53 @@ static int stm32_pwm_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int stm32_pwm_suspend(struct device *dev)
+{
+	struct stm32_pwm *priv = dev_get_drvdata(dev);
+	unsigned int i;
+
+	for (i = 0; i < priv->chip.npwm; i++) {
+		pwm_get_state(&priv->chip.pwms[i], &priv->suspend[i]);
+		priv->suspended[i] = priv->suspend[i].enabled;
+
+		/* safe to call pwm_disable() for already disabled pwm */
+		pwm_disable(&priv->chip.pwms[i]);
+	}
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int stm32_pwm_resume(struct device *dev)
+{
+	struct stm32_pwm *priv = dev_get_drvdata(dev);
+	unsigned int i;
+	int ret;
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret)
+		return ret;
+
+	ret = stm32_pwm_apply_breakinputs(priv);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < priv->chip.npwm; i++) {
+		/* Only resume active pwm, not to disrupt other MFD child */
+		if (!priv->suspended[i])
+			continue;
+
+		ret = pwm_apply_state(&priv->chip.pwms[i], &priv->suspend[i]);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(stm32_pwm_pm_ops, stm32_pwm_suspend, stm32_pwm_resume);
+
 static const struct of_device_id stm32_pwm_of_match[] = {
 	{ .compatible = "st,stm32-pwm",	},
 	{ /* end node */ },
@@ -657,6 +713,7 @@ static struct platform_driver stm32_pwm_driver = {
 	.driver	= {
 		.name = "stm32-pwm",
 		.of_match_table = stm32_pwm_of_match,
+		.pm = &stm32_pwm_pm_ops,
 	},
 };
 module_platform_driver(stm32_pwm_driver);
diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 7c71cdb..ceb233d 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -249,6 +249,7 @@ static void pwm_export_release(struct device *child)
 static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 {
 	struct pwm_export *export;
+	char *pwm_prop[2];
 	int ret;
 
 	if (test_and_set_bit(PWMF_EXPORTED, &pwm->flags))
@@ -263,7 +264,6 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	export->pwm = pwm;
 	mutex_init(&export->lock);
 
-	export->child.class = parent->class;
 	export->child.release = pwm_export_release;
 	export->child.parent = parent;
 	export->child.devt = MKDEV(0, 0);
@@ -277,6 +277,10 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 		export = NULL;
 		return ret;
 	}
+	pwm_prop[0] = kasprintf(GFP_KERNEL, "EXPORT=pwm%u", pwm->hwpwm);
+	pwm_prop[1] = NULL;
+	kobject_uevent_env(&parent->kobj, KOBJ_CHANGE, pwm_prop);
+	kfree(pwm_prop[0]);
 
 	return 0;
 }
@@ -289,6 +293,7 @@ static int pwm_unexport_match(struct device *child, void *data)
 static int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)
 {
 	struct device *child;
+	char *pwm_prop[2];
 
 	if (!test_and_clear_bit(PWMF_EXPORTED, &pwm->flags))
 		return -ENODEV;
@@ -297,6 +302,11 @@ static int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)
 	if (!child)
 		return -ENODEV;
 
+	pwm_prop[0] = kasprintf(GFP_KERNEL, "UNEXPORT=pwm%u", pwm->hwpwm);
+	pwm_prop[1] = NULL;
+	kobject_uevent_env(&parent->kobj, KOBJ_CHANGE, pwm_prop);
+	kfree(pwm_prop[0]);
+
 	/* for device_find_child() */
 	put_device(child);
 	device_unregister(child);
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 329cdd3..9ecafba 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -803,6 +803,25 @@ config REGULATOR_STM32_VREFBUF
 	  This driver can also be built as a module. If so, the module
 	  will be called stm32-vrefbuf.
 
+config REGULATOR_STM32_PWR
+	bool "STMicroelectronics STM32 PWR"
+	depends on ARCH_STM32
+	help
+	  This driver supports internal regulators (1V1 & 1V8) in the
+	  STMicroelectronics STM32 chips.
+
+config REGULATOR_STPMIC1
+	tristate "STMicroelectronics STPMIC1 PMIC Regulators"
+	depends on MFD_STPMIC1
+	help
+	  This driver supports STMicroelectronics STPMIC1 PMIC voltage
+	  regulators and switches. The STPMIC1 regulators supply power to
+	  an application processor as well as to external system
+	  peripherals such as DDR, Flash memories and system devices.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called stpmic1_regulator.
+
 config REGULATOR_TI_ABB
 	tristate "TI Adaptive Body Bias on-chip LDO"
 	depends on ARCH_OMAP
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 801d9a3..3506ec2 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -101,6 +101,8 @@ obj-$(CONFIG_REGULATOR_S5M8767) += s5m8767.o
 obj-$(CONFIG_REGULATOR_SC2731) += sc2731-regulator.o
 obj-$(CONFIG_REGULATOR_SKY81452) += sky81452-regulator.o
 obj-$(CONFIG_REGULATOR_STM32_VREFBUF) += stm32-vrefbuf.o
+obj-$(CONFIG_REGULATOR_STM32_PWR) += stm32-pwr.o
+obj-$(CONFIG_REGULATOR_STPMIC1) += stpmic1_regulator.o
 obj-$(CONFIG_REGULATOR_STW481X_VMMC) += stw481x-vmmc.o
 obj-$(CONFIG_REGULATOR_SY8106A) += sy8106a-regulator.o
 obj-$(CONFIG_REGULATOR_TI_ABB) += ti-abb-regulator.o
diff --git a/drivers/regulator/stm32-pwr.c b/drivers/regulator/stm32-pwr.c
new file mode 100644
index 0000000..f4e1198
--- /dev/null
+++ b/drivers/regulator/stm32-pwr.c
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2017
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com>
+ *
+ * License terms: GPL V2.0.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+/*
+ * Registers
+ */
+#define REG_PWR_CR3 0x0C
+
+/*
+ * SYSTEM_PARAMETER
+ */
+#define REG_1_1_EN  BIT(30)
+#define REG_1_8_EN  BIT(28)
+#define USB_3_3_EN  BIT(24)
+
+#define STM32_SMC_PWR		0x82001001
+#define STM32_WRITE		0x1
+#define STM32_SMC_REG_SET	0x2
+#define STM32_SMC_REG_CLEAR	0x3
+
+#define SMC(class, op, address, val)\
+	({\
+	struct arm_smccc_res res;\
+	arm_smccc_smc(class, op, address, val,\
+			0, 0, 0, 0, &res);\
+	})
+
+static int stm32_pwr_secure_regulator_enable(struct regulator_dev *rdev)
+{
+	SMC(STM32_SMC_PWR, STM32_SMC_REG_SET, rdev->desc->enable_reg,
+	    rdev->desc->enable_mask);
+
+	return 0;
+}
+
+static int stm32_pwr_secure_regulator_disable(struct regulator_dev *rdev)
+{
+	SMC(STM32_SMC_PWR, STM32_SMC_REG_CLEAR, rdev->desc->enable_reg,
+	    rdev->desc->enable_mask);
+
+	return 0;
+}
+
+static const struct regulator_ops stm32_pwr_reg_ops = {
+	.list_voltage	= regulator_list_voltage_linear,
+	.enable		= regulator_enable_regmap,
+	.disable	= regulator_disable_regmap,
+	.is_enabled	= regulator_is_enabled_regmap,
+};
+
+static const struct regulator_ops stm32_pwr_reg_secure_ops = {
+	.list_voltage	= regulator_list_voltage_linear,
+	.enable		= stm32_pwr_secure_regulator_enable,
+	.disable	= stm32_pwr_secure_regulator_disable,
+	.is_enabled	= regulator_is_enabled_regmap,
+};
+
+static const struct regulator_desc stm32_pwr_reg11 = {
+	.name = "REG11",
+	.of_match = of_match_ptr("reg11"),
+	.n_voltages = 1,
+	.type = REGULATOR_VOLTAGE,
+	.min_uV = 1100000,
+	.fixed_uV = 1100000,
+	.ops = &stm32_pwr_reg_ops,
+	.enable_reg = REG_PWR_CR3,
+	.enable_mask = REG_1_1_EN,
+	.owner = THIS_MODULE,
+};
+
+static const struct regulator_desc stm32_pwr_reg18 = {
+	.name = "REG18",
+	.of_match = of_match_ptr("reg18"),
+	.n_voltages = 1,
+	.type = REGULATOR_VOLTAGE,
+	.min_uV = 1800000,
+	.fixed_uV = 1800000,
+	.ops = &stm32_pwr_reg_ops,
+	.enable_reg = REG_PWR_CR3,
+	.enable_mask = REG_1_8_EN,
+	.owner = THIS_MODULE,
+};
+
+static const struct regulator_desc stm32_pwr_usb33 = {
+	.name = "USB33",
+	.of_match = of_match_ptr("usb33"),
+	.n_voltages = 1,
+	.type = REGULATOR_VOLTAGE,
+	.min_uV = 3300000,
+	.fixed_uV = 3300000,
+	.ops = &stm32_pwr_reg_ops,
+	.enable_reg = REG_PWR_CR3,
+	.enable_mask = USB_3_3_EN,
+	.owner = THIS_MODULE,
+};
+
+static struct of_regulator_match stm32_pwr_reg_matches[] = {
+	{ .name = "reg11", .driver_data = (void *)&stm32_pwr_reg11 },
+	{ .name = "reg18", .driver_data = (void *)&stm32_pwr_reg18 },
+	{ .name = "usb33", .driver_data = (void *)&stm32_pwr_usb33 },
+};
+
+#define STM32PWR_REG_NUM_REGS ARRAY_SIZE(stm32_pwr_reg_matches)
+
+static int is_stm32_soc_secured(struct platform_device *pdev, int *val)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct regmap *syscon;
+	u32 reg, mask;
+	int tzc_val = 0;
+	int err;
+
+	syscon = syscon_regmap_lookup_by_phandle(np, "st,tzcr");
+	if (IS_ERR(syscon)) {
+		dev_err(&pdev->dev, "tzcr syscon required !\n");
+		return PTR_ERR(syscon);
+	}
+
+	err = of_property_read_u32_index(np, "st,tzcr", 1, &reg);
+	if (err) {
+		dev_err(&pdev->dev, "tzcr offset required !\n");
+		return err;
+	}
+
+	err = of_property_read_u32_index(np, "st,tzcr", 2, &mask);
+	if (err) {
+		dev_err(&pdev->dev, "tzcr mask required !\n");
+		return err;
+	}
+
+	err = regmap_read(syscon, reg, &tzc_val);
+	if (err) {
+		dev_err(&pdev->dev, "failed to read tzcr status !\n");
+		return err;
+	}
+
+	*val = tzc_val & mask;
+
+	return 0;
+}
+
+static int stm32_power_regulator_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct regulator_dev *rdev;
+	struct regulator_config config = { };
+	struct regmap *regmap;
+	struct regulator_desc *desc;
+	int i, ret = 0;
+	int tzen = 0;
+
+	of_regulator_match(&pdev->dev, np, stm32_pwr_reg_matches,
+			   STM32PWR_REG_NUM_REGS);
+
+	regmap = syscon_node_to_regmap(pdev->dev.parent->of_node);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	config.regmap = regmap;
+	config.dev = &pdev->dev;
+
+	ret = is_stm32_soc_secured(pdev, &tzen);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < STM32PWR_REG_NUM_REGS; i++) {
+		struct of_regulator_match *match = &stm32_pwr_reg_matches[i];
+
+		if (!match->init_data ||
+		    !match->of_node)
+			continue;
+
+		config.init_data = match->init_data;
+		config.driver_data = match->driver_data;
+		config.of_node = match->of_node;
+
+		if  (tzen) {
+			desc = match->driver_data;
+			desc->ops = &stm32_pwr_reg_secure_ops;
+		}
+
+		rdev = devm_regulator_register(&pdev->dev,
+					       match->driver_data,
+					       &config);
+		if (IS_ERR(rdev)) {
+			ret = PTR_ERR(rdev);
+			dev_err(&pdev->dev,
+				"Failed to register regulator: %d\n", ret);
+			break;
+		}
+	}
+	return ret;
+}
+
+static const struct of_device_id stm32_pwr_reg_of_match[] = {
+	{ .compatible = "st,stm32mp1,pwr-reg", },
+	{},
+};
+
+static struct platform_driver stm32_pwr_reg_driver = {
+	.probe = stm32_power_regulator_probe,
+	.driver = {
+		.name = "stm32-pwr-regulator",
+		.of_match_table = of_match_ptr(stm32_pwr_reg_of_match),
+	},
+};
+
+static int __init stm32_pwr_regulator_init(void)
+{
+	return platform_driver_register(&stm32_pwr_reg_driver);
+}
+subsys_initcall(stm32_pwr_regulator_init);
diff --git a/drivers/regulator/stm32-vrefbuf.c b/drivers/regulator/stm32-vrefbuf.c
index e0a9c44..29cca32 100644
--- a/drivers/regulator/stm32-vrefbuf.c
+++ b/drivers/regulator/stm32-vrefbuf.c
@@ -15,6 +15,7 @@
 #include <linux/platform_device.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/of_regulator.h>
+#include <linux/pm_runtime.h>
 
 /* STM32 VREFBUF registers */
 #define STM32_VREFBUF_CSR		0x00
@@ -25,9 +26,12 @@
 #define STM32_HIZ			BIT(1)
 #define STM32_ENVR			BIT(0)
 
+#define STM32_VREFBUF_AUTO_SUSPEND_DELAY_MS	10
+
 struct stm32_vrefbuf {
 	void __iomem *base;
 	struct clk *clk;
+	struct device *dev;
 };
 
 static const unsigned int stm32_vrefbuf_voltages[] = {
@@ -38,9 +42,16 @@ static const unsigned int stm32_vrefbuf_voltages[] = {
 static int stm32_vrefbuf_enable(struct regulator_dev *rdev)
 {
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
-	u32 val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
+	u32 val;
 	int ret;
 
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(priv->dev);
+		return ret;
+	}
+
+	val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
 	val = (val & ~STM32_HIZ) | STM32_ENVR;
 	writel_relaxed(val, priv->base + STM32_VREFBUF_CSR);
 
@@ -59,45 +70,95 @@ static int stm32_vrefbuf_enable(struct regulator_dev *rdev)
 		writel_relaxed(val, priv->base + STM32_VREFBUF_CSR);
 	}
 
+	pm_runtime_mark_last_busy(priv->dev);
+	pm_runtime_put_autosuspend(priv->dev);
+
 	return ret;
 }
 
 static int stm32_vrefbuf_disable(struct regulator_dev *rdev)
 {
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
-	u32 val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
+	u32 val;
+	int ret;
 
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(priv->dev);
+		return ret;
+	}
+
+	val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
 	val = (val & ~STM32_ENVR) | STM32_HIZ;
 	writel_relaxed(val, priv->base + STM32_VREFBUF_CSR);
 
+	pm_runtime_mark_last_busy(priv->dev);
+	pm_runtime_put_autosuspend(priv->dev);
+
 	return 0;
 }
 
 static int stm32_vrefbuf_is_enabled(struct regulator_dev *rdev)
 {
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
+	int ret;
 
-	return readl_relaxed(priv->base + STM32_VREFBUF_CSR) & STM32_ENVR;
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(priv->dev);
+		return ret;
+	}
+
+	ret = readl_relaxed(priv->base + STM32_VREFBUF_CSR) & STM32_ENVR;
+
+	pm_runtime_mark_last_busy(priv->dev);
+	pm_runtime_put_autosuspend(priv->dev);
+
+	return ret;
 }
 
 static int stm32_vrefbuf_set_voltage_sel(struct regulator_dev *rdev,
 					 unsigned sel)
 {
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
-	u32 val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
+	u32 val;
+	int ret;
 
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(priv->dev);
+		return ret;
+	}
+
+	val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
 	val = (val & ~STM32_VRS) | FIELD_PREP(STM32_VRS, sel);
 	writel_relaxed(val, priv->base + STM32_VREFBUF_CSR);
 
+	pm_runtime_mark_last_busy(priv->dev);
+	pm_runtime_put_autosuspend(priv->dev);
+
 	return 0;
 }
 
 static int stm32_vrefbuf_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
-	u32 val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
+	u32 val;
+	int ret;
 
-	return FIELD_GET(STM32_VRS, val);
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret < 0) {
+		pm_runtime_put_noidle(priv->dev);
+		return ret;
+	}
+
+	val = readl_relaxed(priv->base + STM32_VREFBUF_CSR);
+	ret = FIELD_GET(STM32_VRS, val);
+
+	pm_runtime_mark_last_busy(priv->dev);
+	pm_runtime_put_autosuspend(priv->dev);
+
+	return ret;
 }
 
 static const struct regulator_ops stm32_vrefbuf_volt_ops = {
@@ -130,6 +191,7 @@ static int stm32_vrefbuf_probe(struct platform_device *pdev)
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
+	priv->dev = &pdev->dev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	priv->base = devm_ioremap_resource(&pdev->dev, res);
@@ -140,10 +202,17 @@ static int stm32_vrefbuf_probe(struct platform_device *pdev)
 	if (IS_ERR(priv->clk))
 		return PTR_ERR(priv->clk);
 
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev,
+					 STM32_VREFBUF_AUTO_SUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
 	ret = clk_prepare_enable(priv->clk);
 	if (ret) {
 		dev_err(&pdev->dev, "clk prepare failed with error %d\n", ret);
-		return ret;
+		goto err_pm_stop;
 	}
 
 	config.dev = &pdev->dev;
@@ -161,10 +230,17 @@ static int stm32_vrefbuf_probe(struct platform_device *pdev)
 	}
 	platform_set_drvdata(pdev, rdev);
 
+	pm_runtime_mark_last_busy(&pdev->dev);
+	pm_runtime_put_autosuspend(&pdev->dev);
+
 	return 0;
 
 err_clk_dis:
 	clk_disable_unprepare(priv->clk);
+err_pm_stop:
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
 
 	return ret;
 }
@@ -174,12 +250,44 @@ static int stm32_vrefbuf_remove(struct platform_device *pdev)
 	struct regulator_dev *rdev = platform_get_drvdata(pdev);
 	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
 
+	pm_runtime_get_sync(&pdev->dev);
 	regulator_unregister(rdev);
 	clk_disable_unprepare(priv->clk);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
 
 	return 0;
 };
 
+#if defined(CONFIG_PM)
+static int stm32_vrefbuf_runtime_suspend(struct device *dev)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int stm32_vrefbuf_runtime_resume(struct device *dev)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);
+
+	return clk_prepare_enable(priv->clk);
+}
+#endif
+
+static const struct dev_pm_ops stm32_vrefbuf_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(stm32_vrefbuf_runtime_suspend,
+			   stm32_vrefbuf_runtime_resume,
+			   NULL)
+};
+
 static const struct of_device_id stm32_vrefbuf_of_match[] = {
 	{ .compatible = "st,stm32-vrefbuf", },
 	{},
@@ -192,6 +300,7 @@ static struct platform_driver stm32_vrefbuf_driver = {
 	.driver = {
 		.name  = "stm32-vrefbuf",
 		.of_match_table = of_match_ptr(stm32_vrefbuf_of_match),
+		.pm = &stm32_vrefbuf_pm_ops,
 	},
 };
 module_platform_driver(stm32_vrefbuf_driver);
diff --git a/drivers/regulator/stpmic1_regulator.c b/drivers/regulator/stpmic1_regulator.c
new file mode 100644
index 0000000..96f1808
--- /dev/null
+++ b/drivers/regulator/stpmic1_regulator.c
@@ -0,0 +1,674 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) STMicroelectronics 2018
+// Author: Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
+
+#include <linux/interrupt.h>
+#include <linux/mfd/stpmic1.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+
+/**
+ * stpmic1 regulator description
+ * @desc: regulator framework description
+ * @mask_reset_reg: mask reset register address
+ * @mask_reset_mask: mask rank and mask reset register mask
+ * @icc_reg: icc register address
+ * @icc_mask: icc register mask
+ */
+struct stpmic1_regulator_cfg {
+	struct regulator_desc desc;
+	u8 mask_reset_reg;
+	u8 mask_reset_mask;
+	u8 icc_reg;
+	u8 icc_mask;
+};
+
+/**
+ * stpmic1 regulator data: this structure is used as driver data
+ * @regul_id: regulator id
+ * @reg_node: DT node of regulator (unused on non-DT platforms)
+ * @cfg: stpmic specific regulator description
+ * @mask_reset: mask_reset bit value
+ * @irq_curlim: current limit interrupt number
+ * @regmap: point to parent regmap structure
+ */
+struct stpmic1_regulator {
+	unsigned int regul_id;
+	struct device_node *reg_node;
+	struct stpmic1_regulator_cfg *cfg;
+	u8 mask_reset;
+	int irq_curlim;
+	struct regmap *regmap;
+};
+
+static int stpmic1_set_mode(struct regulator_dev *rdev, unsigned int mode);
+static unsigned int stpmic1_get_mode(struct regulator_dev *rdev);
+static int stpmic1_set_icc(struct regulator_dev *rdev);
+static int stpmic1_regulator_parse_dt(void *driver_data);
+static unsigned int stpmic1_map_mode(unsigned int mode);
+
+enum {
+	STPMIC1_BUCK1 = 0,
+	STPMIC1_BUCK2 = 1,
+	STPMIC1_BUCK3 = 2,
+	STPMIC1_BUCK4 = 3,
+	STPMIC1_LDO1 = 4,
+	STPMIC1_LDO2 = 5,
+	STPMIC1_LDO3 = 6,
+	STPMIC1_LDO4 = 7,
+	STPMIC1_LDO5 = 8,
+	STPMIC1_LDO6 = 9,
+	STPMIC1_VREF_DDR = 10,
+	STPMIC1_BOOST = 11,
+	STPMIC1_VBUS_OTG = 12,
+	STPMIC1_SW_OUT = 13,
+};
+
+/* Enable time worst case is 5000mV/(2250uV/uS) */
+#define PMIC_ENABLE_TIME_US 2200
+
+#define STPMIC1_BUCK_MODE_NORMAL 0
+#define STPMIC1_BUCK_MODE_LP BUCK_HPLP_ENABLE_MASK
+
+struct regulator_linear_range buck1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0, 30, 25000),
+	REGULATOR_LINEAR_RANGE(1350000, 31, 63, 0),
+};
+
+struct regulator_linear_range buck2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1000000, 0, 17, 0),
+	REGULATOR_LINEAR_RANGE(1050000, 18, 19, 0),
+	REGULATOR_LINEAR_RANGE(1100000, 20, 21, 0),
+	REGULATOR_LINEAR_RANGE(1150000, 22, 23, 0),
+	REGULATOR_LINEAR_RANGE(1200000, 24, 25, 0),
+	REGULATOR_LINEAR_RANGE(1250000, 26, 27, 0),
+	REGULATOR_LINEAR_RANGE(1300000, 28, 29, 0),
+	REGULATOR_LINEAR_RANGE(1350000, 30, 31, 0),
+	REGULATOR_LINEAR_RANGE(1400000, 32, 33, 0),
+	REGULATOR_LINEAR_RANGE(1450000, 34, 35, 0),
+	REGULATOR_LINEAR_RANGE(1500000, 36, 63, 0),
+};
+
+struct regulator_linear_range buck3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1000000, 0, 19, 0),
+	REGULATOR_LINEAR_RANGE(1100000, 20, 23, 0),
+	REGULATOR_LINEAR_RANGE(1200000, 24, 27, 0),
+	REGULATOR_LINEAR_RANGE(1300000, 28, 31, 0),
+	REGULATOR_LINEAR_RANGE(1400000, 32, 35, 0),
+	REGULATOR_LINEAR_RANGE(1500000, 36, 55, 100000),
+	REGULATOR_LINEAR_RANGE(3400000, 56, 63, 0),
+
+};
+
+struct regulator_linear_range buck4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0, 27, 25000),
+	REGULATOR_LINEAR_RANGE(1300000, 28, 29, 0),
+	REGULATOR_LINEAR_RANGE(1350000, 30, 31, 0),
+	REGULATOR_LINEAR_RANGE(1400000, 32, 33, 0),
+	REGULATOR_LINEAR_RANGE(1450000, 34, 35, 0),
+	REGULATOR_LINEAR_RANGE(1500000, 36, 60, 100000),
+	REGULATOR_LINEAR_RANGE(3900000, 61, 63, 0),
+
+};
+
+struct regulator_linear_range ldo1_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),
+	REGULATOR_LINEAR_RANGE(1700000, 8, 24, 100000),
+	REGULATOR_LINEAR_RANGE(3300000, 25, 31, 0),
+
+};
+
+struct regulator_linear_range ldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),
+	REGULATOR_LINEAR_RANGE(1700000, 8, 24, 100000),
+	REGULATOR_LINEAR_RANGE(3300000, 25, 30, 0),
+
+};
+
+struct regulator_linear_range ldo3_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),
+	REGULATOR_LINEAR_RANGE(1700000, 8, 24, 100000),
+	REGULATOR_LINEAR_RANGE(3300000, 25, 30, 0),
+	/* with index 31 LDO3 is in DDR mode */
+	REGULATOR_LINEAR_RANGE(500000, 31, 31, 0),
+};
+
+struct regulator_linear_range ldo5_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),
+	REGULATOR_LINEAR_RANGE(1700000, 8, 30, 100000),
+	REGULATOR_LINEAR_RANGE(3900000, 31, 31, 0),
+};
+
+struct regulator_linear_range ldo6_ranges[] = {
+	REGULATOR_LINEAR_RANGE(900000, 0, 24, 100000),
+	REGULATOR_LINEAR_RANGE(3300000, 25, 31, 0),
+};
+
+static struct regulator_ops stpmic1_ldo_ops = {
+	.list_voltage = regulator_list_voltage_linear_range,
+	.map_voltage = regulator_map_voltage_linear_range,
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.set_pull_down = regulator_set_pull_down_regmap,
+	.set_over_current_protection = stpmic1_set_icc,
+};
+
+static struct regulator_ops stpmic1_ldo3_ops = {
+	.list_voltage = regulator_list_voltage_linear_range,
+	.map_voltage = regulator_map_voltage_iterate,
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.set_pull_down = regulator_set_pull_down_regmap,
+	.get_bypass = regulator_get_bypass_regmap,
+	.set_bypass = regulator_set_bypass_regmap,
+	.set_over_current_protection = stpmic1_set_icc,
+};
+
+static struct regulator_ops stpmic1_ldo4_fixed_regul_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.set_pull_down = regulator_set_pull_down_regmap,
+	.set_over_current_protection = stpmic1_set_icc,
+};
+
+static struct regulator_ops stpmic1_buck_ops = {
+	.list_voltage = regulator_list_voltage_linear_range,
+	.map_voltage = regulator_map_voltage_linear_range,
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.set_pull_down = regulator_set_pull_down_regmap,
+	.set_mode = stpmic1_set_mode,
+	.get_mode = stpmic1_get_mode,
+	.set_over_current_protection = stpmic1_set_icc,
+};
+
+static struct regulator_ops stpmic1_vref_ddr_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.set_pull_down = regulator_set_pull_down_regmap,
+};
+
+static struct regulator_ops stpmic1_switch_regul_ops = {
+	.is_enabled = regulator_is_enabled_regmap,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.set_over_current_protection = stpmic1_set_icc,
+};
+
+#define REG_LDO(ids, base) { \
+	.name = #ids, \
+	.id = STPMIC1_##ids, \
+	.n_voltages = 32, \
+	.ops = &stpmic1_ldo_ops, \
+	.linear_ranges = base ## _ranges, \
+	.n_linear_ranges = ARRAY_SIZE(base ## _ranges), \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.vsel_reg = ids##_ACTIVE_CR, \
+	.vsel_mask = LDO_VOLTAGE_MASK, \
+	.enable_reg = ids##_ACTIVE_CR, \
+	.enable_mask = LDO_ENABLE_MASK, \
+	.enable_val = 1, \
+	.disable_val = 0, \
+	.enable_time = PMIC_ENABLE_TIME_US, \
+	.pull_down_reg = ids##_PULL_DOWN_REG, \
+	.pull_down_mask = ids##_PULL_DOWN_MASK, \
+	.supply_name = #base, \
+}
+
+#define REG_LDO3(ids, base) { \
+	.name = #ids, \
+	.id = STPMIC1_##ids, \
+	.n_voltages = 32, \
+	.ops = &stpmic1_ldo3_ops, \
+	.linear_ranges = ldo3_ranges, \
+	.n_linear_ranges = ARRAY_SIZE(ldo3_ranges), \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.vsel_reg = LDO3_ACTIVE_CR, \
+	.vsel_mask = LDO_VOLTAGE_MASK, \
+	.enable_reg = LDO3_ACTIVE_CR, \
+	.enable_mask = LDO_ENABLE_MASK, \
+	.enable_val = 1, \
+	.disable_val = 0, \
+	.enable_time = PMIC_ENABLE_TIME_US, \
+	.bypass_reg = LDO3_ACTIVE_CR, \
+	.bypass_mask = LDO_BYPASS_MASK, \
+	.bypass_val_on = LDO_BYPASS_MASK, \
+	.bypass_val_off = 0, \
+	.pull_down_reg = ids##_PULL_DOWN_REG, \
+	.pull_down_mask = ids##_PULL_DOWN_MASK, \
+	.supply_name = #base, \
+}
+
+#define REG_LDO4(ids, base) { \
+	.name = #ids, \
+	.id = STPMIC1_##ids, \
+	.n_voltages = 1, \
+	.ops = &stpmic1_ldo4_fixed_regul_ops, \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.min_uV = 3300000, \
+	.fixed_uV = 3300000, \
+	.enable_reg = LDO4_ACTIVE_CR, \
+	.enable_mask = LDO_ENABLE_MASK, \
+	.enable_val = 1, \
+	.disable_val = 0, \
+	.enable_time = PMIC_ENABLE_TIME_US, \
+	.pull_down_reg = ids##_PULL_DOWN_REG, \
+	.pull_down_mask = ids##_PULL_DOWN_MASK, \
+	.supply_name = #base, \
+}
+
+#define REG_BUCK(ids, base) { \
+	.name = #ids, \
+	.id = STPMIC1_##ids, \
+	.ops = &stpmic1_buck_ops, \
+	.n_voltages = 64, \
+	.linear_ranges = base ## _ranges, \
+	.n_linear_ranges = ARRAY_SIZE(base ## _ranges), \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.vsel_reg = ids##_ACTIVE_CR, \
+	.vsel_mask = BUCK_VOLTAGE_MASK, \
+	.enable_reg = ids##_ACTIVE_CR, \
+	.enable_mask = BUCK_ENABLE_MASK, \
+	.enable_val = 1, \
+	.disable_val = 0, \
+	.enable_time = PMIC_ENABLE_TIME_US, \
+	.of_map_mode = stpmic1_map_mode, \
+	.pull_down_reg = ids##_PULL_DOWN_REG, \
+	.pull_down_mask = ids##_PULL_DOWN_MASK, \
+	.supply_name = #base, \
+}
+
+#define REG_VREF_DDR(ids, base) { \
+	.name = #ids, \
+	.id = STPMIC1_##ids, \
+	.n_voltages = 1, \
+	.ops = &stpmic1_vref_ddr_ops, \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.min_uV = 500000, \
+	.fixed_uV = 500000, \
+	.enable_reg = VREF_DDR_ACTIVE_CR, \
+	.enable_mask = BUCK_ENABLE_MASK, \
+	.enable_val = 1, \
+	.disable_val = 0, \
+	.enable_time = PMIC_ENABLE_TIME_US, \
+	.pull_down_reg = ids##_PULL_DOWN_REG, \
+	.pull_down_mask = ids##_PULL_DOWN_MASK, \
+	.supply_name = #base, \
+}
+
+#define REG_SWITCH(ids, base, reg, mask, val) { \
+	.name = #ids, \
+	.id = STPMIC1_##ids, \
+	.n_voltages = 1, \
+	.ops = &stpmic1_switch_regul_ops, \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.min_uV = 0, \
+	.fixed_uV = 5000000, \
+	.enable_reg = (reg), \
+	.enable_mask = (mask), \
+	.enable_val = (val), \
+	.disable_val = 0, \
+	.enable_time = PMIC_ENABLE_TIME_US, \
+	.supply_name = #base, \
+}
+
+struct stpmic1_regulator_cfg stpmic1_regulator_cfgs[] = {
+	[STPMIC1_BUCK1] = {
+		.desc = REG_BUCK(BUCK1, buck1),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(0),
+		.mask_reset_reg = BUCKS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(0),
+	},
+	[STPMIC1_BUCK2] = {
+		.desc = REG_BUCK(BUCK2, buck2),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(1),
+		.mask_reset_reg = BUCKS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(1),
+	},
+	[STPMIC1_BUCK3] = {
+		.desc = REG_BUCK(BUCK3, buck3),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(2),
+		.mask_reset_reg = BUCKS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(2),
+	},
+	[STPMIC1_BUCK4] = {
+		.desc = REG_BUCK(BUCK4, buck4),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(3),
+		.mask_reset_reg = BUCKS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(3),
+	},
+	[STPMIC1_LDO1] = {
+		.desc = REG_LDO(LDO1, ldo1),
+		.icc_reg = LDOS_ICCTO_CR,
+		.icc_mask = BIT(0),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(0),
+	},
+	[STPMIC1_LDO2] = {
+		.desc = REG_LDO(LDO2, ldo2),
+		.icc_reg = LDOS_ICCTO_CR,
+		.icc_mask = BIT(1),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(1),
+	},
+	[STPMIC1_LDO3] = {
+		.desc = REG_LDO3(LDO3, ldo3),
+		.icc_reg = LDOS_ICCTO_CR,
+		.icc_mask = BIT(2),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(2),
+	},
+	[STPMIC1_LDO4] = {
+		.desc = REG_LDO4(LDO4, ldo4),
+		.icc_reg = LDOS_ICCTO_CR,
+		.icc_mask = BIT(3),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(3),
+	},
+	[STPMIC1_LDO5] = {
+		.desc = REG_LDO(LDO5, ldo5),
+		.icc_reg = LDOS_ICCTO_CR,
+		.icc_mask = BIT(4),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(4),
+	},
+	[STPMIC1_LDO6] = {
+		.desc = REG_LDO(LDO6, ldo6),
+		.icc_reg = LDOS_ICCTO_CR,
+		.icc_mask = BIT(5),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(5),
+	},
+	[STPMIC1_VREF_DDR] = {
+		.desc = REG_VREF_DDR(VREF_DDR, vref_ddr),
+		.mask_reset_reg = LDOS_MASK_RESET_CR,
+		.mask_reset_mask = BIT(6),
+	},
+	[STPMIC1_BOOST] = {
+		.desc = REG_SWITCH(BOOST, boost, BST_SW_CR,
+				   BOOST_ENABLED,
+				   BOOST_ENABLED),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(6),
+	},
+	[STPMIC1_VBUS_OTG] = {
+		.desc = REG_SWITCH(VBUS_OTG, pwr_sw1, BST_SW_CR,
+				   USBSW_OTG_SWITCH_ENABLED,
+				   USBSW_OTG_SWITCH_ENABLED),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(4),
+	},
+	[STPMIC1_SW_OUT] = {
+		.desc = REG_SWITCH(SW_OUT, pwr_sw2, BST_SW_CR,
+				   SWIN_SWOUT_ENABLED,
+				   SWIN_SWOUT_ENABLED),
+		.icc_reg = BUCKS_ICCTO_CR,
+		.icc_mask = BIT(5),
+	},
+};
+
+static unsigned int stpmic1_map_mode(unsigned int mode)
+{
+	switch (mode) {
+	case STPMIC1_BUCK_MODE_NORMAL:
+		return REGULATOR_MODE_NORMAL;
+	case STPMIC1_BUCK_MODE_LP:
+		return REGULATOR_MODE_STANDBY;
+	default:
+		return -EINVAL;
+	}
+}
+
+static unsigned int stpmic1_get_mode(struct regulator_dev *rdev)
+{
+	int value;
+
+	regmap_read(rdev->regmap, rdev->desc->enable_reg, &value);
+
+	if (value & STPMIC1_BUCK_MODE_LP)
+		return REGULATOR_MODE_STANDBY;
+
+	return REGULATOR_MODE_NORMAL;
+}
+
+static int stpmic1_set_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	int value;
+
+	switch (mode) {
+	case REGULATOR_MODE_NORMAL:
+		value = STPMIC1_BUCK_MODE_NORMAL;
+		break;
+	case REGULATOR_MODE_STANDBY:
+		value = STPMIC1_BUCK_MODE_LP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
+				  STPMIC1_BUCK_MODE_LP, value);
+}
+
+static int stpmic1_set_icc(struct regulator_dev *rdev)
+{
+	struct stpmic1_regulator *regul = rdev_get_drvdata(rdev);
+
+	/* enable switch off in case of over current */
+	return regmap_update_bits(regul->regmap, regul->cfg->icc_reg,
+				  regul->cfg->icc_mask, regul->cfg->icc_mask);
+}
+
+static irqreturn_t stpmic1_curlim_irq_handler(int irq, void *data)
+{
+	struct regulator_dev *rdev = (struct regulator_dev *)data;
+
+	mutex_lock(&rdev->mutex);
+
+	/* Send an overcurrent notification */
+	regulator_notifier_call_chain(rdev,
+				      REGULATOR_EVENT_OVER_CURRENT,
+				      NULL);
+
+	mutex_unlock(&rdev->mutex);
+
+	return IRQ_HANDLED;
+}
+
+static int stpmic1_regulator_init(struct platform_device *pdev,
+				  struct regulator_dev *rdev)
+{
+	struct stpmic1_regulator *regul = rdev_get_drvdata(rdev);
+	int ret = 0;
+
+	/* set mask reset */
+	if (regul->mask_reset && regul->cfg->mask_reset_reg != 0) {
+		ret = regmap_update_bits(regul->regmap,
+					 regul->cfg->mask_reset_reg,
+					 regul->cfg->mask_reset_mask,
+					 regul->cfg->mask_reset_mask);
+		if (ret) {
+			dev_err(&pdev->dev, "set mask reset failed\n");
+			return ret;
+		}
+	}
+
+	/* setup an irq handler for over-current detection */
+	if (regul->irq_curlim > 0) {
+		ret = devm_request_threaded_irq(&pdev->dev,
+						regul->irq_curlim, NULL,
+						stpmic1_curlim_irq_handler,
+						IRQF_ONESHOT | IRQF_SHARED,
+						pdev->name, rdev);
+		if (ret) {
+			dev_err(&pdev->dev, "Request IRQ failed\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+#define MATCH(_name, _id) \
+	[STPMIC1_##_id] = { \
+		.name = #_name, \
+		.desc = &stpmic1_regulator_cfgs[STPMIC1_##_id].desc, \
+	}
+
+static struct of_regulator_match stpmic1_regulators_matches[] = {
+	MATCH(buck1, BUCK1),
+	MATCH(buck2, BUCK2),
+	MATCH(buck3, BUCK3),
+	MATCH(buck4, BUCK4),
+	MATCH(ldo1, LDO1),
+	MATCH(ldo2, LDO2),
+	MATCH(ldo3, LDO3),
+	MATCH(ldo4, LDO4),
+	MATCH(ldo5, LDO5),
+	MATCH(ldo6, LDO6),
+	MATCH(vref_ddr, VREF_DDR),
+	MATCH(boost, BOOST),
+	MATCH(pwr_sw1, VBUS_OTG),
+	MATCH(pwr_sw2, SW_OUT),
+};
+
+static int stpmic1_regulator_parse_dt(void *driver_data)
+{
+	struct stpmic1_regulator *regul =
+		(struct stpmic1_regulator *)driver_data;
+
+	if (!regul)
+		return -EINVAL;
+
+	if (of_get_property(regul->reg_node, "st,mask-reset", NULL))
+		regul->mask_reset = 1;
+
+	regul->irq_curlim = of_irq_get(regul->reg_node, 0);
+
+	return 0;
+}
+
+static struct
+regulator_dev *stpmic1_regulator_register(struct platform_device *pdev, int id,
+					  struct regulator_init_data *init_data,
+					  struct stpmic1_regulator *regul)
+{
+	struct stpmic1 *pmic_dev = dev_get_drvdata(pdev->dev.parent);
+	struct regulator_dev *rdev;
+	struct regulator_config config = {};
+
+	config.dev = &pdev->dev;
+	config.init_data = init_data;
+	config.of_node = stpmic1_regulators_matches[id].of_node;
+	config.regmap = pmic_dev->regmap;
+	config.driver_data = regul;
+
+	regul->regul_id = id;
+	regul->reg_node = config.of_node;
+	regul->cfg = &stpmic1_regulator_cfgs[id];
+	regul->regmap = pmic_dev->regmap;
+
+	rdev = devm_regulator_register(&pdev->dev, &regul->cfg->desc, &config);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register %s regulator\n",
+			regul->cfg->desc.name);
+	}
+
+	return rdev;
+}
+
+static int stpmic1_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev;
+	struct stpmic1_regulator *regul;
+	struct regulator_init_data *init_data;
+	struct device_node *np;
+	int i, ret;
+
+	np = pdev->dev.of_node;
+
+	ret = of_regulator_match(&pdev->dev, np,
+				 stpmic1_regulators_matches,
+				 ARRAY_SIZE(stpmic1_regulators_matches));
+	if (ret < 0) {
+		dev_err(&pdev->dev,
+			"Error in PMIC regulator device tree node");
+		return ret;
+	}
+
+	regul = devm_kzalloc(&pdev->dev, ARRAY_SIZE(stpmic1_regulator_cfgs) *
+			     sizeof(struct stpmic1_regulator),
+			     GFP_KERNEL);
+	if (!regul)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(stpmic1_regulator_cfgs); i++) {
+		/* Parse DT & find regulators to register */
+		init_data = stpmic1_regulators_matches[i].init_data;
+		if (init_data)
+			init_data->regulator_init = &stpmic1_regulator_parse_dt;
+
+		rdev = stpmic1_regulator_register(pdev, i, init_data, regul);
+		if (IS_ERR(rdev))
+			return PTR_ERR(rdev);
+
+		ret = stpmic1_regulator_init(pdev, rdev);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to initialize regulator %d\n", ret);
+			return ret;
+		}
+
+		regul++;
+	}
+
+	dev_dbg(&pdev->dev, "stpmic1_regulator driver probed\n");
+
+	return 0;
+}
+
+static const struct of_device_id of_pmic_regulator_match[] = {
+	{ .compatible = "st,stpmic1-regulators" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, of_pmic_regulator_match);
+
+static struct platform_driver stpmic1_regulator_driver = {
+	.driver = {
+		.name = "stpmic1-regulator",
+		.of_match_table = of_match_ptr(of_pmic_regulator_match),
+	},
+	.probe = stpmic1_regulator_probe,
+};
+
+module_platform_driver(stpmic1_regulator_driver);
+
+MODULE_DESCRIPTION("STPMIC1 PMIC voltage regulator driver");
+MODULE_AUTHOR("Pascal Paillet <p.paillet@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/reset/reset-stm32mp1.c b/drivers/reset/reset-stm32mp1.c
index b221a28..d46c47b 100644
--- a/drivers/reset/reset-stm32mp1.c
+++ b/drivers/reset/reset-stm32mp1.c
@@ -4,6 +4,7 @@
  * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
  */
 
+#include <linux/arm-smccc.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/io.h>
@@ -13,11 +14,50 @@
 
 #define CLR_OFFSET 0x4
 
+#define STM32_RCC_TZCR 0x0
+#define CLR_OFFSET 0x4
+
+#define STM32MP1_SVC_RCC 0x82001000
+
+#define SMT32_SPI6_R 3136
+#define STM32_AXIM_R 3216
+#define STM32_MCU_R 8225
+
 struct stm32_reset_data {
 	struct reset_controller_dev	rcdev;
 	void __iomem			*membase;
 };
 
+static int soc_secured;
+
+static int is_stm32_id_secured(unsigned long id)
+{
+	if (id >= SMT32_SPI6_R && id <= STM32_AXIM_R)
+		return 1;
+
+	if (id == STM32_MCU_R)
+		return 1;
+
+	return 0;
+}
+
+static int reset_stm32_secure_update(struct reset_controller_dev *rcdev,
+				     unsigned long id, bool assert)
+{
+	struct arm_smccc_res res;
+	int bank = id / BITS_PER_LONG;
+	int offset = id % BITS_PER_LONG;
+
+	if (assert)
+		arm_smccc_smc(STM32MP1_SVC_RCC, 0x1, (bank * 4),
+			      BIT(offset), 0, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(STM32MP1_SVC_RCC, 0x1, (bank * 4) + CLR_OFFSET,
+			      BIT(offset), 0, 0, 0, 0, &res);
+
+	return 0;
+}
+
 static inline struct stm32_reset_data *
 to_stm32_reset_data(struct reset_controller_dev *rcdev)
 {
@@ -45,12 +85,18 @@ static int stm32_reset_update(struct reset_controller_dev *rcdev,
 static int stm32_reset_assert(struct reset_controller_dev *rcdev,
 			      unsigned long id)
 {
+	if (soc_secured && is_stm32_id_secured(id))
+		return reset_stm32_secure_update(rcdev, id, true);
+
 	return stm32_reset_update(rcdev, id, true);
 }
 
 static int stm32_reset_deassert(struct reset_controller_dev *rcdev,
 				unsigned long id)
 {
+	if (soc_secured && is_stm32_id_secured(id))
+		return reset_stm32_secure_update(rcdev, id, false);
+
 	return stm32_reset_update(rcdev, id, false);
 }
 
@@ -101,6 +147,8 @@ static int stm32_reset_probe(struct platform_device *pdev)
 	data->rcdev.ops = &stm32_reset_ops;
 	data->rcdev.of_node = dev->of_node;
 
+	soc_secured = readl(membase + STM32_RCC_TZCR) & 0x1;
+
 	return devm_reset_controller_register(dev, &data->rcdev);
 }
 
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 7d7be60..6e201ff 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1770,6 +1770,7 @@ config RTC_DRV_R7301
 config RTC_DRV_STM32
 	tristate "STM32 RTC"
 	select REGMAP_MMIO
+	depends on COMMON_CLK
 	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	   If you say yes here you get support for the STM32 On-Chip
diff --git a/drivers/rtc/rtc-stm32.c b/drivers/rtc/rtc-stm32.c
index c5908cf..87f26c1 100644
--- a/drivers/rtc/rtc-stm32.c
+++ b/drivers/rtc/rtc-stm32.c
@@ -6,6 +6,7 @@
 
 #include <linux/bcd.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/iopoll.h>
 #include <linux/ioport.h>
 #include <linux/mfd/syscon.h>
@@ -15,6 +16,8 @@
 #include <linux/regmap.h>
 #include <linux/rtc.h>
 
+#include <dt-bindings/rtc/rtc-stm32.h>
+
 #define DRIVER_NAME "stm32_rtc"
 
 /* STM32_RTC_TR bit fields  */
@@ -39,6 +42,12 @@
 #define STM32_RTC_CR_FMT		BIT(6)
 #define STM32_RTC_CR_ALRAE		BIT(8)
 #define STM32_RTC_CR_ALRAIE		BIT(12)
+#define STM32_RTC_CR_COSEL		BIT(19)
+#define STM32_RTC_CR_OSEL_SHIFT		21
+#define STM32_RTC_CR_OSEL		GENMASK(22, 21)
+#define STM32_RTC_CR_COE		BIT(23)
+#define STM32_RTC_CR_TAMPOE		BIT(26)
+#define STM32_RTC_CR_OUT2EN		BIT(31)
 
 /* STM32_RTC_ISR/STM32_RTC_ICSR bit fields */
 #define STM32_RTC_ISR_ALRAWF		BIT(0)
@@ -75,6 +84,11 @@
 /* STM32_RTC_SR/_SCR bit fields */
 #define STM32_RTC_SR_ALRA		BIT(0)
 
+/* STM32_RTC_CFGR bit fields */
+#define STM32_RTC_CFGR_OUT2_RMP		BIT(0)
+#define STM32_RTC_CFGR_LSCOEN_OUT1	1
+#define STM32_RTC_CFGR_LSCOEN_OUT2_RMP	2
+
 /* STM32_RTC_VERR bit fields */
 #define STM32_RTC_VERR_MINREV_SHIFT	0
 #define STM32_RTC_VERR_MINREV		GENMASK(3, 0)
@@ -101,6 +115,7 @@ struct stm32_rtc_registers {
 	u16 wpr;
 	u16 sr;
 	u16 scr;
+	u16 cfgr;
 	u16 verr;
 };
 
@@ -115,6 +130,7 @@ struct stm32_rtc_data {
 	bool has_pclk;
 	bool need_dbp;
 	bool has_wakeirq;
+	bool has_lsco;
 };
 
 struct stm32_rtc {
@@ -128,8 +144,87 @@ struct stm32_rtc {
 	const struct stm32_rtc_data *data;
 	int irq_alarm;
 	int wakeirq_alarm;
+	int lsco;
+	struct clk *clk_lsco;
 };
 
+/*
+ *  -------------------------------------------------------------------------
+ * | TAMPOE | OSEL[1:0] | COE | OUT2EN |     RTC_OUT1     |     RTC_OUT2     |
+ * |	    |           |     |        |                  | or RTC_OUT2_RMP  |
+ * |-------------------------------------------------------------------------|
+ * |    0   |     00    |  0  | 0 or 1 |         -        |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * |    0   |     00    |  1  |    0   |      CALIB       |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  0  |    0   |     TAMPALRM     |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * |    0   |     00    |  1  |    1   |         -        |      CALIB       |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  0  |    1   |         -        |     TAMPALRM     |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  1  |    1   |     TAMPALRM     |      CALIB       |
+ *  -------------------------------------------------------------------------
+ */
+static int stm32_rtc_clk_lsco_check_availability(struct stm32_rtc *rtc)
+{
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+	unsigned int calib = STM32_RTC_CR_COE;
+	unsigned int tampalrm = STM32_RTC_CR_TAMPOE | STM32_RTC_CR_OSEL;
+
+	switch (rtc->lsco) {
+	case RTC_OUT1:
+		if ((!(cr & STM32_RTC_CR_OUT2EN) &&
+		     ((cr & calib) || cr & tampalrm)) ||
+		     ((cr & calib) && (cr & tampalrm)))
+			return -EBUSY;
+		break;
+	case RTC_OUT2_RMP:
+		if ((cr & STM32_RTC_CR_OUT2EN) &&
+		    (cfgr & STM32_RTC_CFGR_OUT2_RMP) &&
+		    ((cr & calib) || (cr & tampalrm)))
+			return -EBUSY;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (clk_get_rate(rtc->rtc_ck) != 32768)
+		return -ERANGE;
+
+	return 0;
+}
+
+static int stm32_rtc_clk_lsco_register(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	u8 lscoen;
+	int ret;
+
+	ret = stm32_rtc_clk_lsco_check_availability(rtc);
+	if (ret)
+		return ret;
+
+	lscoen = (rtc->lsco == RTC_OUT1) ? STM32_RTC_CFGR_LSCOEN_OUT1 :
+					   STM32_RTC_CFGR_LSCOEN_OUT2_RMP;
+
+	rtc->clk_lsco = clk_register_gate(&pdev->dev, "rtc_lsco",
+					  __clk_get_name(rtc->rtc_ck),
+					  CLK_IGNORE_UNUSED | CLK_IS_CRITICAL,
+					  rtc->base + regs.cfgr, lscoen,
+					  0, NULL);
+	if (IS_ERR(rtc->clk_lsco))
+		return PTR_ERR(rtc->clk_lsco);
+
+	of_clk_add_provider(pdev->dev.of_node,
+			    of_clk_src_simple_get, rtc->clk_lsco);
+
+	return 0;
+}
+
 static void stm32_rtc_wpr_unlock(struct stm32_rtc *rtc)
 {
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
@@ -552,6 +647,7 @@ static const struct stm32_rtc_data stm32_rtc_data = {
 	.has_pclk = false,
 	.need_dbp = true,
 	.has_wakeirq = false,
+	.has_lsco = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -562,6 +658,7 @@ static const struct stm32_rtc_data stm32_rtc_data = {
 		.wpr = 0x24,
 		.sr = 0x0C, /* set to ISR offset to ease alarm management */
 		.scr = UNDEF_REG,
+		.cfgr = UNDEF_REG,
 		.verr = UNDEF_REG,
 	},
 	.events = {
@@ -574,6 +671,7 @@ static const struct stm32_rtc_data stm32h7_rtc_data = {
 	.has_pclk = true,
 	.need_dbp = true,
 	.has_wakeirq = false,
+	.has_lsco = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -584,6 +682,7 @@ static const struct stm32_rtc_data stm32h7_rtc_data = {
 		.wpr = 0x24,
 		.sr = 0x0C, /* set to ISR offset to ease alarm management */
 		.scr = UNDEF_REG,
+		.cfgr = UNDEF_REG,
 		.verr = UNDEF_REG,
 	},
 	.events = {
@@ -605,6 +704,7 @@ static const struct stm32_rtc_data stm32mp1_data = {
 	.has_pclk = true,
 	.need_dbp = false,
 	.has_wakeirq = true,
+	.has_lsco = true,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -615,6 +715,7 @@ static const struct stm32_rtc_data stm32mp1_data = {
 		.wpr = 0x24,
 		.sr = 0x50,
 		.scr = 0x5C,
+		.cfgr = 0x60,
 		.verr = 0x3F4,
 	},
 	.events = {
@@ -818,6 +919,21 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	if (rtc->data->has_lsco) {
+		ret = of_property_read_s32(pdev->dev.of_node,
+					   "st,lsco", &rtc->lsco);
+		if (!ret) {
+			ret = stm32_rtc_clk_lsco_register(pdev);
+			if (ret)
+				dev_warn(&pdev->dev,
+					 "LSCO clock registration failed: %d\n",
+					 ret);
+		} else {
+			rtc->lsco = ret;
+			dev_dbg(&pdev->dev, "No LSCO clock: %d\n", ret);
+		}
+	}
+
 	/*
 	 * If INITS flag is reset (calendar year field set to 0x00), calendar
 	 * must be initialized
@@ -854,6 +970,9 @@ static int stm32_rtc_remove(struct platform_device *pdev)
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
 	unsigned int cr;
 
+	if (!IS_ERR_OR_NULL(rtc->clk_lsco))
+		clk_unregister_gate(rtc->clk_lsco);
+
 	/* Disable interrupts */
 	stm32_rtc_wpr_unlock(rtc);
 	cr = readl_relaxed(rtc->base + regs->cr);
diff --git a/include/dt-bindings/pinctrl/stm32-pinfunc.h b/include/dt-bindings/pinctrl/stm32-pinfunc.h
index b5a2174..e928aea 100644
--- a/include/dt-bindings/pinctrl/stm32-pinfunc.h
+++ b/include/dt-bindings/pinctrl/stm32-pinfunc.h
@@ -32,5 +32,11 @@
 
 #define STM32_PINMUX(port, line, mode) (((PIN_NO(port, line)) << 8) | (mode))
 
+/*  package information */
+#define STM32MP157CAA	0x1
+#define STM32MP157CAB	0x2
+#define STM32MP157CAC	0x4
+#define STM32MP157CAD	0x8
+
 #endif /* _DT_BINDINGS_STM32_PINFUNC_H */
 
diff --git a/include/dt-bindings/rtc/rtc-stm32.h b/include/dt-bindings/rtc/rtc-stm32.h
new file mode 100644
index 0000000..4373c4d
--- /dev/null
+++ b/include/dt-bindings/rtc/rtc-stm32.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for STM32_RTC bindings.
+ */
+
+#ifndef _DT_BINDINGS_RTC_RTC_STM32_H
+#define _DT_BINDINGS_RTC_RTC_STM32_H
+
+#define RTC_OUT1	0
+#define RTC_OUT2	1
+#define RTC_OUT2_RMP	2
+
+#endif
-- 
2.7.4

